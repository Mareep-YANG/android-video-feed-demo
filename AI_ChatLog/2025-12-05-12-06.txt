
 â–â–›â–ˆâ–ˆâ–ˆâ–œâ–Œ   Claude Code v2.0.19
â–â–œâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–›â–˜  Sonnet 4.5 Â· API Usage Billing
  â–˜â–˜ â–â–    /Users/leiyang/Documents/WorkSpace/AndroidProjects/android-video-feed-demo

> ä¸ºä»€ä¹ˆè¦åšåˆ†é¡µåŠ è½½ï¼Œå¯¹äºè¿™ä¸ªé¡¹ç›®æ¥è¯´ï¼Œæœ‰æ²¡æœ‰åŸºç¡€çš„æŠ€æœ¯æ–¹æ¡ˆ 

âº åœ¨è§†é¢‘æµåº”ç”¨ä¸­å®ç°åˆ†é¡µåŠ è½½æ˜¯ä¸€ä¸ªé‡è¦çš„æŠ€æœ¯å†³ç­–ã€‚è®©æˆ‘åˆ†æä¸€ä¸‹åŸå› å’ŒæŠ€æœ¯æ–¹æ¡ˆã€‚

  ä¸ºä»€ä¹ˆéœ€è¦åˆ†é¡µåŠ è½½

  1. æ€§èƒ½ä¼˜åŒ–

  - å†…å­˜ç®¡ç†: ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰è§†é¢‘æ•°æ®ä¼šå ç”¨å¤§é‡å†…å­˜,å¯èƒ½å¯¼è‡´ OOM (å†…å­˜æº¢å‡º)
  - å¯åŠ¨é€Ÿåº¦: é¦–å±åªåŠ è½½å°‘é‡æ•°æ®,å¤§å¹…æå‡åº”ç”¨å¯åŠ¨å’Œåˆæ¬¡åŠ è½½é€Ÿåº¦
  - æµç•…åº¦: å‡å°‘å•æ¬¡ç½‘ç»œè¯·æ±‚æ•°æ®é‡,é™ä½ UI çº¿ç¨‹é˜»å¡é£é™©

  2. ç”¨æˆ·ä½“éªŒ

  - å¿«é€Ÿå“åº”: ç”¨æˆ·æ— éœ€ç­‰å¾…æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆ
  - æ¸è¿›å¼åŠ è½½: è¾¹æ»‘åŠ¨è¾¹åŠ è½½,æä¾›è¿ç»­çš„æµè§ˆä½“éªŒ
  - èŠ‚çœæµé‡: ç”¨æˆ·å¯èƒ½ä¸ä¼šæµè§ˆæ‰€æœ‰å†…å®¹,æŒ‰éœ€åŠ è½½é¿å…æµé‡æµªè´¹

  3. æœåŠ¡å™¨å‹åŠ›

  - å‡å°‘å•æ¬¡è¯·æ±‚æ•°æ®é‡,é™ä½æœåŠ¡å™¨è´Ÿè½½
  - æ›´åˆç†çš„èµ„æºåˆ†é…

  åŸºç¡€æŠ€æœ¯æ–¹æ¡ˆ

  åŸºäºä½ é¡¹ç›®ç°æœ‰çš„æŠ€æœ¯æ ˆ,æœ‰ä»¥ä¸‹å‡ ç§æ–¹æ¡ˆ:

  æ–¹æ¡ˆä¸€: Paging 3 Library (æ¨è)

  è¿™æ˜¯ Google å®˜æ–¹çš„åˆ†é¡µè§£å†³æ–¹æ¡ˆ,ä¸ä½ ç°æœ‰çš„æ¶æ„å®Œç¾å¥‘åˆ:

  æ ¸å¿ƒç»„ä»¶:
  PagingSource -> Repository -> ViewModel -> PagingData -> RecyclerView.Adapter

  ä¼˜åŠ¿:
  - ä¸ MVVMã€LiveDataã€Roomã€Hilt æ— ç¼é›†æˆ
  - è‡ªåŠ¨å¤„ç†åŠ è½½çŠ¶æ€ã€é”™è¯¯é‡è¯•ã€å»é‡
  - å†…ç½®å†…å­˜å’Œæ•°æ®åº“ç¼“å­˜æ”¯æŒ
  - æ”¯æŒç½‘ç»œ+æœ¬åœ°æ··åˆæ•°æ®æº

  å·¥ä½œæµç¨‹:
  1. å®šä¹‰ PagingSource ä»ç½‘ç»œæˆ–æ•°æ®åº“è·å–åˆ†é¡µæ•°æ®
  2. Repository è¿”å› Flow<PagingData>
  3. ViewModel é€šè¿‡ cachedIn() ç¼“å­˜æ•°æ®
  4. UI ä½¿ç”¨ PagingDataAdapter å±•ç¤º

  ---
  æ–¹æ¡ˆäºŒ: æ‰‹åŠ¨å®ç° (ç®€å•åœºæ™¯)

  å¦‚æœæ•°æ®é€»è¾‘ç®€å•,å¯ä»¥æ‰‹åŠ¨æ§åˆ¶:

  æ ¸å¿ƒé€»è¾‘:
  - ç»´æŠ¤ currentPage å’Œ isLoading çŠ¶æ€
  - ç›‘å¬ RecyclerView æ»‘åŠ¨åˆ°åº•éƒ¨äº‹ä»¶
  - è§¦å‘åŠ è½½ä¸‹ä¸€é¡µæ•°æ®

  é€‚ç”¨åœºæ™¯:
  - åˆ†é¡µé€»è¾‘ç®€å•
  - ä¸éœ€è¦å¤æ‚çš„ç¼“å­˜ç­–ç•¥
  - å¿«é€ŸåŸå‹å¼€å‘

  ---
  æ–¹æ¡ˆä¸‰: Jetpack Compose + Paging

  å¦‚æœæœªæ¥è€ƒè™‘è¿ç§»åˆ° Compose UI:

  - ä½¿ç”¨ collectAsLazyPagingItems()
  - ä¸ LazyColumn é…åˆ
  - å£°æ˜å¼ UI è‡ªåŠ¨å¤„ç†åˆ†é¡µ

  ---
  é’ˆå¯¹ä½ çš„é¡¹ç›®å»ºè®®

  è€ƒè™‘åˆ°ä½ çš„é¡¹ç›®å·²ç»ä½¿ç”¨äº†:
  - âœ… MVVM æ¶æ„
  - âœ… Room Database
  - âœ… LiveData/ViewModel
  - âœ… Hilt
  - âœ… RecyclerView

  æ¨èä½¿ç”¨ Paging 3,å› ä¸º:

  1. æœ€å°æ”¹åŠ¨: åªéœ€æ·»åŠ  Paging åº“ä¾èµ–,ç°æœ‰æ¶æ„å‡ ä¹ä¸ç”¨è°ƒæ•´
  2. åŠŸèƒ½å®Œå–„: è‡ªåŠ¨å¤„ç†åŠ è½½çŠ¶æ€ã€é¢„åŠ è½½ã€é”™è¯¯é‡è¯•
  3. å®˜æ–¹æ”¯æŒ: Google ç»´æŠ¤,é•¿æœŸç¨³å®š
  4. å­¦ä¹ ä»·å€¼: ä¸šç•Œæ ‡å‡†æ–¹æ¡ˆ

  éœ€è¦æˆ‘è¯¦ç»†è¯´æ˜ Paging 3 çš„é›†æˆæ­¥éª¤,è¿˜æ˜¯ä½ æœ‰å…¶ä»–è€ƒè™‘?

> æ­£å¸¸æ¥è¯´ ç±»ä¼¼æŠ–éŸ³ã€ä»Šæ—¥å¤´æ¡è¿™ç§è§†é¢‘æµï¼Œç½‘ç»œå»¶è¿Ÿä¼šæ˜¯å¤šå°‘ï¼Œæˆ‘åœ¨è·å–åˆ†é¡µçš„æ—¶å€™ï¼Œå¤§æ¦‚éœ€è¦æ¨¡æ‹Ÿå¤šä¹…çš„ç½‘ç»œå»¶è¿Ÿ 

âº æ ¹æ®å®é™…åº”ç”¨åœºæ™¯ï¼Œæˆ‘æ¥åˆ†æä¸€ä¸‹çœŸå®çš„ç½‘ç»œå»¶è¿Ÿæƒ…å†µï¼š

  çœŸå®ä¸–ç•Œçš„ç½‘ç»œå»¶è¿Ÿæ•°æ®

  1. æŠ–éŸ³/TikTok ç±»çŸ­è§†é¢‘åº”ç”¨

  API è¯·æ±‚å»¶è¿Ÿ (è·å–è§†é¢‘åˆ—è¡¨):
  - 4G ç½‘ç»œ: 200-500ms
  - 5G ç½‘ç»œ: 100-300ms
  - WiFi (è‰¯å¥½): 150-400ms
  - WiFi (ä¸€èˆ¬): 300-800ms
  - å¼±ç½‘ç¯å¢ƒ: 1000-3000ms

  è§†é¢‘é¦–å¸§åŠ è½½:
  - 4G: 300-800ms
  - 5G: 200-500ms
  - WiFi: 250-600ms

  2. ä»Šæ—¥å¤´æ¡ç±»èµ„è®¯æµ

  Feed æµæ¥å£å»¶è¿Ÿ:
  - 4G: 150-400ms
  - WiFi: 100-300ms
  - å¼±ç½‘: 800-2000ms

  3. å½±å“å› ç´ 

  - CDN è·ç¦»: å°±è¿‘èŠ‚ç‚¹å¯é™ä½ 50-100ms
  - æœåŠ¡å™¨å“åº”æ—¶é—´: é€šå¸¸ 50-200ms
  - æ•°æ®å¤§å°: 10 æ¡è§†é¢‘ä¿¡æ¯çº¦ 50-200KB
  - è¿è¥å•†è´¨é‡: ç§»åŠ¨/è”é€š/ç”µä¿¡å·®å¼‚å¯è¾¾ 100-300ms

  ---
  æ¨¡æ‹Ÿå»ºè®®

  æ¨èçš„æ¨¡æ‹Ÿå»¶è¿Ÿè®¾ç½®

  // æµ‹è¯•åœºæ™¯å»ºè®®
  enum class NetworkCondition(val delay: Long) {
      EXCELLENT(200L),    // 5G/ä¼˜è´¨WiFi - æå°‘ä½¿ç”¨
      GOOD(500L),         // 4Gè‰¯å¥½ - æ—¥å¸¸ä¸»è¦åœºæ™¯
      NORMAL(1000L),      // 4Gä¸€èˆ¬/WiFiæ‹¥æŒ¤ - å¸¸è§åœºæ™¯
      POOR(2000L),        // å¼±ç½‘ - éœ€è¦è€ƒè™‘çš„åœºæ™¯
      VERY_POOR(3500L)    // æå·®ç½‘ç»œ - è¾¹ç¼˜åœºæ™¯
  }

  å¼€å‘é˜¶æ®µæ¨èå€¼

  | å¼€å‘é˜¶æ®µ   | æ¨èå»¶è¿Ÿ        | ç†ç”±         |
  |--------|-------------|------------|
  | æ—¥å¸¸å¼€å‘   | 500-800ms   | æ¨¡æ‹ŸçœŸå® 4G ç¯å¢ƒ |
  | ç”¨æˆ·ä½“éªŒæµ‹è¯• | 1000-1500ms | æµ‹è¯•åŠ è½½çŠ¶æ€ã€éª¨æ¶å± |
  | æç«¯æµ‹è¯•   | 3000ms+     | éªŒè¯è¶…æ—¶ã€é‡è¯•é€»è¾‘  |
  | æœ€ä½³æƒ…å†µ   | 200-300ms   | éªŒè¯æµç•…ä½“éªŒä¸Šé™   |

  ---
  å®é™…å®ç°å‚è€ƒ

  // åœ¨ä½ çš„ç½‘ç»œå±‚å¯ä»¥è¿™æ ·æ¨¡æ‹Ÿ
  class NetworkInterceptor : Interceptor {
      override fun intercept(chain: Interceptor.Chain): Response {
          // å¼€å‘ç¯å¢ƒæ¨¡æ‹Ÿå»¶è¿Ÿ
          if (BuildConfig.DEBUG) {
              val delay = when (SimulatedNetworkCondition.current) {
                  NetworkCondition.GOOD -> 500L
                  NetworkCondition.NORMAL -> 1000L
                  NetworkCondition.POOR -> 2000L
                  else -> 300L
              }
              Thread.sleep(delay)
          }
          return chain.proceed(chain.request())
      }
  }

  ---
  æ ¸å¿ƒå»ºè®®

  åˆ†é¡µåŠ è½½çš„å»¶è¿Ÿè®¾ç½®:

  1. ä¸»å¼€å‘ç¯å¢ƒ: 800ms
    - æ¥è¿‘çœŸå® 4G ä½“éªŒ
    - èƒ½æ„ŸçŸ¥åŠ è½½è¿‡ç¨‹ä½†ä¸ä¼šå¤ªæ…¢
    - å®¹æ˜“å‘ç° UI é—®é¢˜
  2. å‹åŠ›æµ‹è¯•: 1500-2000ms
    - æµ‹è¯•ç”¨æˆ·ç­‰å¾…è€å¿ƒ
    - éªŒè¯åŠ è½½æç¤ºæ˜¯å¦å‹å¥½
    - æ£€æŸ¥æ˜¯å¦æœ‰ ANR é£é™©
  3. å¿«é€Ÿè¿­ä»£: 300ms
    - å¼€å‘è°ƒè¯•é˜¶æ®µæé«˜æ•ˆç‡
    - ä½†è¦å®šæœŸåˆ‡æ¢åˆ°çœŸå®å»¶è¿Ÿæµ‹è¯•

  ---
  é¢å¤–å»ºè®®

  çœŸå®æ•°æ®å‚è€ƒ:

  - æŠ–éŸ³é¦–å±é€šå¸¸é¢„åŠ è½½ 5-8 æ¡ è§†é¢‘
  - è§¦å‘åŠ è½½é˜ˆå€¼: å‰©ä½™ 2-3 æ¡ æ—¶å¼€å§‹è¯·æ±‚
  - æ¯æ¬¡åˆ†é¡µåŠ è½½: 10-15 æ¡

  ä¼˜åŒ–ç‚¹:

  - å®ç°é¢„åŠ è½½æœºåˆ¶ (æ»‘åŠ¨åˆ°å€’æ•°ç¬¬ 3 ä¸ªå¼€å§‹åŠ è½½)
  - æ·»åŠ è¯·æ±‚å»é‡ (é˜²æ­¢å¿«é€Ÿæ»‘åŠ¨è§¦å‘å¤šæ¬¡è¯·æ±‚)
  - ç¼“å­˜ç­–ç•¥ (ä¼˜å…ˆæ˜¾ç¤ºç¼“å­˜ï¼Œåå°åˆ·æ–°)

  æˆ‘çš„å»ºè®®æ˜¯ï¼šæ—¥å¸¸å¼€å‘ä½¿ç”¨ 800msï¼Œç”¨æˆ·ä½“éªŒæµ‹è¯•ä½¿ç”¨ 1500msï¼Œå‹åŠ›æµ‹è¯•ä½¿ç”¨ 3000msã€‚è¿™æ ·èƒ½è¦†ç›–å¤§éƒ¨åˆ†çœŸå®åœºæ™¯ã€‚

> è§†é¢‘æš‚åœæ ‡å¿—çš„å®ç° æˆ‘ç°åœ¨æƒ³çš„æ˜¯åœ¨ä¸­é—´é¢„ç•™ä¸€ä¸ªç»„ä»¶ é€šè¿‡æ§åˆ¶è¿™ä¸ªç»„ä»¶çš„å¯è§æ€§æ¥è¿›è¡Œæš‚åœæˆ–ç»§ç»­çš„æé†’ è¿™æ ·çš„å®ç°å¥½å— æœ‰æ²¡æœ‰ä»€ä¹ˆæ›´å¥½çš„æ–¹æ³• 

âº ä½ çš„æ–¹æ¡ˆæ˜¯å¯è¡Œçš„ï¼Œä½†æˆ‘æ¥åˆ†æä¸€ä¸‹ä¸åŒå®ç°æ–¹å¼çš„ä¼˜åŠ£ï¼š

  æ–¹æ¡ˆå¯¹æ¯”

  æ–¹æ¡ˆä¸€ï¼šä¸­é—´å›ºå®šç»„ä»¶ + å¯è§æ€§æ§åˆ¶ï¼ˆä½ å½“å‰çš„æƒ³æ³•ï¼‰

  // ImageView/Lottie åŠ¨ç”»å›ºå®šåœ¨å¸ƒå±€ä¸­å¤®
  <ImageView
      android:id="@+id/ivPlayPauseIcon"
      android:visibility="gone"
      ... />

  ä¼˜åŠ¿ï¼š
  - âœ… å®ç°ç®€å•ï¼Œé€»è¾‘æ¸…æ™°
  - âœ… æ€§èƒ½å¼€é”€å°ï¼ˆåªæ˜¯æ˜¾ç¤º/éšè—ï¼‰
  - âœ… é€‚åˆç®€å•çš„å›¾æ ‡æ˜¾ç¤º

  åŠ£åŠ¿ï¼š
  - âŒ åŠ¨ç”»æ•ˆæœæœ‰é™
  - âŒ æ¯ä¸ª ViewHolder éƒ½éœ€è¦å ç”¨è¿™ä¸ª Viewï¼ˆå³ä½¿ä¸æ˜¾ç¤ºï¼‰
  - âŒ éš¾ä»¥å®ç°å¤æ‚çš„äº¤äº’åŠ¨ç”»

  ---
  æ–¹æ¡ˆäºŒï¼šåŠ¨æ€æ·»åŠ  + åŠ¨ç”»ï¼ˆç±»ä¼¼æŠ–éŸ³ï¼‰

  æŠ–éŸ³çš„åšæ³•ï¼š
  - ç‚¹å‡»æš‚åœï¼šä¸­é—´å‡ºç°æš‚åœå›¾æ ‡ï¼Œå¸¦ç¼©æ”¾+æ·¡å…¥åŠ¨ç”»ï¼Œ1-2 ç§’åè‡ªåŠ¨æ·¡å‡º
  - ç‚¹å‡»æ’­æ”¾ï¼šæ’­æ”¾å›¾æ ‡å¿«é—ªåæ¶ˆå¤±
  - åŒå‡»ç‚¹èµï¼šå¿ƒå½¢åŠ¨ç”»ä»ç‚¹å‡»ä½ç½®é£å‘å³ä¾§

  // åŠ¨æ€æ˜¾ç¤ºå¹¶è‡ªåŠ¨æ¶ˆå¤±
  private fun showPlayPauseIcon(isPaused: Boolean) {
      binding.ivPlayPauseIcon.apply {
          visibility = View.VISIBLE
          setImageResource(if (isPaused) R.drawable.ic_pause else R.drawable.ic_play)

          // ç¼©æ”¾ + æ·¡å…¥åŠ¨ç”»
          alpha = 0f
          scaleX = 0.5f
          scaleY = 0.5f

          animate()
              .alpha(1f)
              .scaleX(1f)
              .scaleY(1f)
              .setDuration(200)
              .withEndAction {
                  // 1.5ç§’åè‡ªåŠ¨æ·¡å‡º
                  postDelayed({
                      animate()
                          .alpha(0f)
                          .setDuration(300)
                          .withEndAction { visibility = View.GONE }
                          .start()
                  }, 1500)
              }
              .start()
      }
  }

  ä¼˜åŠ¿ï¼š
  - âœ… ç”¨æˆ·ä½“éªŒæ›´å¥½ï¼ˆä¸ä¼šä¸€ç›´é®æŒ¡å†…å®¹ï¼‰
  - âœ… ç¬¦åˆä¸»æµåº”ç”¨ä¹ æƒ¯
  - âœ… å¯ä»¥æ·»åŠ ä¸°å¯Œçš„åŠ¨ç”»æ•ˆæœ

  åŠ£åŠ¿ï¼š
  - âš ï¸ ä»£ç ç¨å¤æ‚
  - âš ï¸ éœ€è¦å¤„ç†åŠ¨ç”»å–æ¶ˆï¼ˆå¦‚å¿«é€Ÿç‚¹å‡»ï¼‰

  ---
  æ–¹æ¡ˆä¸‰ï¼šLottie åŠ¨ç”»ï¼ˆé«˜çº§ä½“éªŒï¼‰

  <com.airbnb.lottie.LottieAnimationView
      android:id="@+id/lottiePlayPause"
      android:layout_width="80dp"
      android:layout_height="80dp"
      app:lottie_rawRes="@raw/play_pause_animation"
      android:visibility="gone" />

  ä¼˜åŠ¿ï¼š
  - âœ… åŠ¨ç”»æ•ˆæœä¸“ä¸šï¼ˆå¯ä»¥æœ‰æ’­æ”¾â†’æš‚åœçš„è¿‡æ¸¡åŠ¨ç”»ï¼‰
  - âœ… è®¾è®¡å¸ˆå¯ä»¥è‡ªç”±å®šåˆ¶
  - âœ… æ–‡ä»¶ä½“ç§¯å°

  åŠ£åŠ¿ï¼š
  - âŒ éœ€è¦å¼•å…¥ Lottie ä¾èµ–ï¼ˆä½ é¡¹ç›®é‡Œå·²ç»æœ‰äº†å—ï¼Ÿï¼‰
  - âŒ éœ€è¦è®¾è®¡èµ„æº

  ---
  é’ˆå¯¹ä½ é¡¹ç›®çš„å»ºè®®

  æ¨èæ–¹æ¡ˆï¼šå›ºå®šç»„ä»¶ + è‡ªåŠ¨æ¶ˆå¤±åŠ¨ç”»

  ç»“åˆæ–¹æ¡ˆä¸€å’Œæ–¹æ¡ˆäºŒçš„ä¼˜ç‚¹ï¼š

  // åœ¨ VideoViewHolder æˆ– Fragment ä¸­
  private var hideIconJob: Job? = null

  private fun togglePlayPause(isPaused: Boolean) {
      // 1. æ§åˆ¶æ’­æ”¾çŠ¶æ€
      if (isPaused) {
          player.pause()
      } else {
          player.play()
      }

      // 2. æ˜¾ç¤ºå›¾æ ‡åŠ¨ç”»
      showPlayPauseIcon(isPaused)
  }

  private fun showPlayPauseIcon(isPaused: Boolean) {
      hideIconJob?.cancel() // å–æ¶ˆä¹‹å‰çš„è‡ªåŠ¨éšè—ä»»åŠ¡

      binding.ivPlayPauseIcon.apply {
          // è®¾ç½®å›¾æ ‡
          setImageResource(
              if (isPaused) R.drawable.ic_pause_large
              else R.drawable.ic_play_large
          )

          // æ˜¾ç¤ºåŠ¨ç”»
          if (visibility != View.VISIBLE) {
              visibility = View.VISIBLE
              alpha = 0f
              scaleX = 0.7f
              scaleY = 0.7f
          }

          animate()
              .alpha(1f)
              .scaleX(1f)
              .scaleY(1f)
              .setDuration(200)
              .setInterpolator(OvershootInterpolator())
              .start()
      }

      // 3. åªæœ‰æš‚åœçŠ¶æ€æ‰ä¿æŒæ˜¾ç¤ºï¼Œæ’­æ”¾çŠ¶æ€è‡ªåŠ¨æ¶ˆå¤±
      if (!isPaused) {
          hideIconJob = lifecycleScope.launch {
              delay(800) // æ’­æ”¾å›¾æ ‡æ˜¾ç¤º 0.8 ç§’åæ¶ˆå¤±
              hidePlayPauseIcon()
          }
      }
      // æš‚åœæ—¶å›¾æ ‡ä¸€ç›´æ˜¾ç¤ºï¼Œç›´åˆ°ç‚¹å‡»æ’­æ”¾
  }

  private fun hidePlayPauseIcon() {
      binding.ivPlayPauseIcon.animate()
          .alpha(0f)
          .scaleX(0.7f)
          .scaleY(0.7f)
          .setDuration(200)
          .withEndAction {
              binding.ivPlayPauseIcon.visibility = View.GONE
          }
          .start()
  }

  ---
  äº¤äº’é€»è¾‘å»ºè®®

  ä¸»æµåº”ç”¨çš„åšæ³•ï¼š

  | æ“ä½œ     | å›¾æ ‡æ˜¾ç¤ºé€»è¾‘              |
  |--------|---------------------|
  | ç‚¹å‡»æš‚åœ   | æš‚åœå›¾æ ‡å‡ºç°å¹¶ä¿æŒæ˜¾ç¤º         |
  | ç‚¹å‡»æ’­æ”¾   | æ’­æ”¾å›¾æ ‡å¿«é—ªï¼ˆ0.5-1ç§’ï¼‰åè‡ªåŠ¨æ¶ˆå¤± |
  | æ»‘åŠ¨åˆ‡æ¢è§†é¢‘ | å›¾æ ‡æ¶ˆå¤±ï¼Œæ–°è§†é¢‘è‡ªåŠ¨æ’­æ”¾        |
  | åŒå‡»ç‚¹èµ   | ç‹¬ç«‹çš„å¿ƒå½¢åŠ¨ç”»ï¼Œä¸å½±å“æ’­æ”¾å›¾æ ‡     |

  ---
  å¸ƒå±€å‚è€ƒ

  <!-- åœ¨ä½ çš„ item_video.xml ä¸­ -->
  <androidx.constraintlayout.widget.ConstraintLayout>

      <!-- ExoPlayer è§†é¢‘è§†å›¾ -->
      <com.google.android.exoplayer2.ui.PlayerView
          android:id="@+id/playerView"
          ... />

      <!-- æ’­æ”¾/æš‚åœå›¾æ ‡ - å±…ä¸­æ˜¾ç¤º -->
      <ImageView
          android:id="@+id/ivPlayPauseIcon"
          android:layout_width="64dp"
          android:layout_height="64dp"
          android:visibility="gone"
          android:src="@drawable/ic_play_large"
          android:contentDescription="@string/play_pause"
          app:layout_constraintTop_toTopOf="parent"
          app:layout_constraintBottom_toBottomOf="parent"
          app:layout_constraintStart_toStartOf="parent"
          app:layout_constraintEnd_toEndOf="parent"
          app:tint="@android:color/white"
          android:alpha="0.9" />

      <!-- å…¶ä»– UI å…ƒç´ ... -->

  </androidx.constraintlayout.widget.ConstraintLayout>

  ---
  æ€»ç»“

  ä½ çš„æ–¹æ¡ˆï¼ˆä¸­é—´å›ºå®šç»„ä»¶ï¼‰æ˜¯æ­£ç¡®çš„åŸºç¡€æ€è·¯ï¼Œæˆ‘çš„å»ºè®®æ˜¯åœ¨æ­¤åŸºç¡€ä¸Šæ·»åŠ ï¼š

  1. âœ… ä¿ç•™å›ºå®šç»„ä»¶ï¼ˆé¿å…åŠ¨æ€åˆ›å»ºå¼€é”€ï¼‰
  2. âœ… æ·»åŠ ç¼©æ”¾æ·¡å…¥æ·¡å‡ºåŠ¨ç”»ï¼ˆæå‡ä½“éªŒï¼‰
  3. âœ… æ’­æ”¾æ—¶è‡ªåŠ¨éšè—ï¼Œæš‚åœæ—¶ä¿æŒæ˜¾ç¤ºï¼ˆç¬¦åˆç”¨æˆ·ä¹ æƒ¯ï¼‰
  4. âœ… å¿«é€Ÿç‚¹å‡»æ—¶å–æ¶ˆä¹‹å‰çš„åŠ¨ç”»ï¼ˆé¿å…åŠ¨ç”»æ··ä¹±ï¼‰

  è¿™æ ·æ—¢ä¿æŒäº†å®ç°çš„ç®€å•æ€§ï¼Œåˆèƒ½è¾¾åˆ°ä¸»æµåº”ç”¨çš„ä½“éªŒæ°´å¹³ã€‚éœ€è¦æˆ‘æä¾›å®Œæ•´çš„ä»£ç å®ç°å—ï¼Ÿ

> å¯¹äºæˆ‘è¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘éœ€è¦æ£€æµ‹æ’­æ”¾å™¨çš„æ€§èƒ½æ•°æ®ï¼Œç”¨æ¥æŒ‡å¯¼æˆ‘åšä¼˜åŒ–ï¼Œå› ä¸ºä¾èµ–ExoPlayerå’ŒViewPagerçš„äº‹ä»¶ï¼Œæ˜¯ä¸æ˜¯ç”¨äº‹ä»¶ä»£ç†/æ‹¦æˆªå™¨çš„æ–¹å¼åšåŸ‹ç‚¹ä¼šæ›´å¥½ä¸€ç‚¹ 

âº éå¸¸å¥½çš„æ€è€ƒï¼å¯¹äºæ’­æ”¾å™¨æ€§èƒ½ç›‘æ§ï¼Œä½ çš„æƒ³æ³•æ˜¯å¯¹çš„ã€‚è®©æˆ‘åˆ†æä¸€ä¸‹ä¸åŒæ–¹æ¡ˆï¼š

  æ–¹æ¡ˆå¯¹æ¯”

  æ–¹æ¡ˆä¸€ï¼šäº‹ä»¶æ‹¦æˆªå™¨/ä»£ç†æ¨¡å¼ï¼ˆæ¨èï¼‰

  æ ¸å¿ƒæ€è·¯ï¼š åœ¨å…³é”®ç»„ä»¶ä¸Šæ·»åŠ ç»Ÿä¸€çš„ç›‘å¬å±‚

  // ExoPlayer äº‹ä»¶æ‹¦æˆª
  class PerformanceAnalyticsEventListener : Player.Listener {

      private var videoLoadStartTime = 0L
      private var bufferingStartTime = 0L
      private var totalBufferingTime = 0L

      override fun onPlaybackStateChanged(playbackState: Int) {
          when (playbackState) {
              Player.STATE_BUFFERING -> {
                  bufferingStartTime = System.currentTimeMillis()
                  logEvent("video_buffering_start")
              }
              Player.STATE_READY -> {
                  if (bufferingStartTime > 0) {
                      val bufferingDuration = System.currentTimeMillis() - bufferingStartTime
                      totalBufferingTime += bufferingDuration
                      logEvent("video_buffering_end", mapOf(
                          "duration" to bufferingDuration,
                          "total_buffering" to totalBufferingTime
                      ))
                  }

                  // é¦–å¸§åŠ è½½æ—¶é—´
                  if (videoLoadStartTime > 0) {
                      val loadTime = System.currentTimeMillis() - videoLoadStartTime
                      logEvent("video_first_frame", mapOf("load_time" to loadTime))
                      videoLoadStartTime = 0
                  }
              }
          }
      }

      override fun onPlayerError(error: PlaybackException) {
          logEvent("video_playback_error", mapOf(
              "error_type" to error.errorCode,
              "message" to error.message
          ))
      }

      fun onVideoLoadStart() {
          videoLoadStartTime = System.currentTimeMillis()
          totalBufferingTime = 0L
      }
  }

  ä¼˜åŠ¿ï¼š
  - âœ… æ— ä¾µå…¥æ€§ï¼šä¸šåŠ¡ä»£ç ä¸éœ€è¦æ”¹åŠ¨
  - âœ… ç»Ÿä¸€ç®¡ç†ï¼šæ‰€æœ‰åŸ‹ç‚¹é€»è¾‘é›†ä¸­åœ¨ä¸€å¤„
  - âœ… æ˜“äºå¼€å…³ï¼šå¯ä»¥é€šè¿‡é…ç½®åŠ¨æ€å¯ç”¨/ç¦ç”¨
  - âœ… æ˜“äºæ‰©å±•ï¼šæ–°å¢ç›‘æ§æŒ‡æ ‡åªéœ€ä¿®æ”¹æ‹¦æˆªå™¨
  - âœ… ç¬¦åˆ AOP æ€æƒ³ï¼šå…³æ³¨ç‚¹åˆ†ç¦»

  ---
  æ–¹æ¡ˆäºŒï¼šViewPager2 æ»‘åŠ¨ç›‘å¬æ‹¦æˆª

  // ViewPager2 é¡µé¢åˆ‡æ¢æ€§èƒ½ç›‘æ§
  class ViewPagerAnalyticsCallback : ViewPager2.OnPageChangeCallback() {

      private var pageChangeStartTime = 0L
      private var currentPage = 0

      override fun onPageScrollStateChanged(state: Int) {
          when (state) {
              ViewPager2.SCROLL_STATE_DRAGGING -> {
                  pageChangeStartTime = System.currentTimeMillis()
                  logEvent("page_scroll_start", mapOf("from_page" to currentPage))
              }
              ViewPager2.SCROLL_STATE_IDLE -> {
                  if (pageChangeStartTime > 0) {
                      val scrollDuration = System.currentTimeMillis() - pageChangeStartTime
                      logEvent("page_scroll_end", mapOf(
                          "duration" to scrollDuration,
                          "to_page" to currentPage
                      ))
                  }
              }
          }
      }

      override fun onPageSelected(position: Int) {
          currentPage = position
          logEvent("page_changed", mapOf(
              "page_index" to position,
              "timestamp" to System.currentTimeMillis()
          ))
      }
  }

  ---
  æ–¹æ¡ˆä¸‰ï¼šç»Ÿä¸€çš„æ€§èƒ½ç›‘æ§ç®¡ç†å™¨ï¼ˆæœ€ä½³å®è·µï¼‰

  å°† ExoPlayer å’Œ ViewPager çš„ç›‘æ§æ•´åˆåˆ°ä¸€ä¸ªç®¡ç†å™¨ä¸­ï¼š

  @Singleton
  class VideoPerformanceMonitor @Inject constructor(
      private val analyticsService: AnalyticsService // ä½ çš„åŸ‹ç‚¹æœåŠ¡
  ) {

      // æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡
      data class VideoMetrics(
          val videoUrl: String,
          val firstFrameTime: Long = 0,        // é¦–å¸§åŠ è½½æ—¶é—´
          val totalBufferingTime: Long = 0,    // æ€»å¡é¡¿æ—¶é—´
          val bufferingCount: Int = 0,         // å¡é¡¿æ¬¡æ•°
          val playDuration: Long = 0,          // æ’­æ”¾æ—¶é•¿
          val errorCount: Int = 0,             // é”™è¯¯æ¬¡æ•°
          val pageIndex: Int = 0               // é¡µé¢ä½ç½®
      )

      private val metricsMap = mutableMapOf<String, VideoMetrics>()

      // åˆ›å»º ExoPlayer ç›‘å¬å™¨
      fun createPlayerListener(videoUrl: String, pageIndex: Int): Player.Listener {
          return VideoPlayerListener(videoUrl, pageIndex)
      }

      // åˆ›å»º ViewPager ç›‘å¬å™¨
      fun createViewPagerCallback(): ViewPager2.OnPageChangeCallback {
          return VideoPageChangeCallback()
      }

      // ExoPlayer äº‹ä»¶ç›‘å¬
      private inner class VideoPlayerListener(
          private val videoUrl: String,
          private val pageIndex: Int
      ) : Player.Listener {

          private var loadStartTime = 0L
          private var bufferingStartTime = 0L
          private var playStartTime = 0L

          override fun onPlaybackStateChanged(playbackState: Int) {
              val metrics = metricsMap.getOrPut(videoUrl) {
                  VideoMetrics(videoUrl, pageIndex = pageIndex)
              }

              when (playbackState) {
                  Player.STATE_BUFFERING -> {
                      if (bufferingStartTime == 0L) {
                          bufferingStartTime = System.currentTimeMillis()
                      }
                  }
                  Player.STATE_READY -> {
                      // é¦–å¸§æ—¶é—´
                      if (loadStartTime > 0) {
                          val firstFrameTime = System.currentTimeMillis() - loadStartTime
                          metricsMap[videoUrl] = metrics.copy(firstFrameTime = firstFrameTime)
                          logMetric("first_frame_loaded", videoUrl, firstFrameTime)
                          loadStartTime = 0
                      }

                      // å¡é¡¿ç»“æŸ
                      if (bufferingStartTime > 0) {
                          val bufferingDuration = System.currentTimeMillis() - bufferingStartTime
                          metricsMap[videoUrl] = metrics.copy(
                              totalBufferingTime = metrics.totalBufferingTime + bufferingDuration,
                              bufferingCount = metrics.bufferingCount + 1
                          )
                          logMetric("buffering", videoUrl, bufferingDuration)
                          bufferingStartTime = 0
                      }
                  }
                  Player.STATE_ENDED -> {
                      reportFinalMetrics(videoUrl)
                  }
              }
          }

          override fun onIsPlayingChanged(isPlaying: Boolean) {
              if (isPlaying) {
                  playStartTime = System.currentTimeMillis()
              } else if (playStartTime > 0) {
                  val playDuration = System.currentTimeMillis() - playStartTime
                  val metrics = metricsMap[videoUrl] ?: return
                  metricsMap[videoUrl] = metrics.copy(
                      playDuration = metrics.playDuration + playDuration
                  )
              }
          }

          override fun onPlayerError(error: PlaybackException) {
              val metrics = metricsMap[videoUrl] ?: return
              metricsMap[videoUrl] = metrics.copy(errorCount = metrics.errorCount + 1)
              logError("playback_error", videoUrl, error)
          }

          fun onVideoLoadStart() {
              loadStartTime = System.currentTimeMillis()
          }
      }

      // ViewPager æ»‘åŠ¨ç›‘å¬
      private inner class VideoPageChangeCallback : ViewPager2.OnPageChangeCallback() {
          private var scrollStartTime = 0L

          override fun onPageScrollStateChanged(state: Int) {
              when (state) {
                  ViewPager2.SCROLL_STATE_DRAGGING -> {
                      scrollStartTime = System.currentTimeMillis()
                  }
                  ViewPager2.SCROLL_STATE_IDLE -> {
                      if (scrollStartTime > 0) {
                          val duration = System.currentTimeMillis() - scrollStartTime
                          analyticsService.logEvent("page_scroll_duration", mapOf(
                              "duration" to duration
                          ))
                      }
                  }
              }
          }

          override fun onPageSelected(position: Int) {
              analyticsService.logEvent("video_page_view", mapOf(
                  "page_index" to position,
                  "timestamp" to System.currentTimeMillis()
              ))
          }
      }

      // ä¸ŠæŠ¥æœ€ç»ˆæŒ‡æ ‡
      private fun reportFinalMetrics(videoUrl: String) {
          val metrics = metricsMap[videoUrl] ?: return

          analyticsService.logEvent("video_session_complete", mapOf(
              "video_url" to metrics.videoUrl,
              "first_frame_time" to metrics.firstFrameTime,
              "total_buffering_time" to metrics.totalBufferingTime,
              "buffering_count" to metrics.bufferingCount,
              "play_duration" to metrics.playDuration,
              "error_count" to metrics.errorCount,
              "page_index" to metrics.pageIndex,
              "qoe_score" to calculateQoE(metrics) // ä½“éªŒè´¨é‡è¯„åˆ†
          ))

          metricsMap.remove(videoUrl)
      }

      // è®¡ç®— QoE (Quality of Experience) è¯„åˆ†
      private fun calculateQoE(metrics: VideoMetrics): Float {
          // ç®€åŒ–ç®—æ³•ï¼šåŸºäºé¦–å¸§æ—¶é—´ã€å¡é¡¿ç‡è®¡ç®—
          val bufferingRatio = if (metrics.playDuration > 0) {
              metrics.totalBufferingTime.toFloat() / metrics.playDuration
          } else 0f

          val firstFrameScore = when {
              metrics.firstFrameTime < 500 -> 1.0f
              metrics.firstFrameTime < 1000 -> 0.8f
              metrics.firstFrameTime < 2000 -> 0.5f
              else -> 0.2f
          }

          val bufferingScore = (1 - bufferingRatio).coerceAtLeast(0f)

          return (firstFrameScore * 0.4f + bufferingScore * 0.6f) * 100
      }

      private fun logMetric(event: String, videoUrl: String, value: Long) {
          analyticsService.logEvent("video_$event", mapOf(
              "video_url" to videoUrl,
              "value" to value,
              "timestamp" to System.currentTimeMillis()
          ))
      }

      private fun logError(event: String, videoUrl: String, error: Exception) {
          analyticsService.logEvent("video_$event", mapOf(
              "video_url" to videoUrl,
              "error_type" to error.javaClass.simpleName,
              "error_message" to error.message
          ))
      }
  }

  ---
  ä½¿ç”¨æ–¹å¼

  åœ¨ä½ çš„ MainActivity/Fragment ä¸­ï¼š

  @AndroidEntryPoint
  class MainActivity : AppCompatActivity() {

      @Inject
      lateinit var performanceMonitor: VideoPerformanceMonitor

      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)

          // æ³¨å†Œ ViewPager ç›‘æ§
          binding.viewPager.registerOnPageChangeCallback(
              performanceMonitor.createViewPagerCallback()
          )
      }
  }

  åœ¨ä½ çš„ ViewHolder ä¸­ï¼š

  class VideoViewHolder(
      private val performanceMonitor: VideoPerformanceMonitor
  ) : RecyclerView.ViewHolder(binding.root) {

      private var playerListener: Player.Listener? = null

      fun bind(video: Video, position: Int) {
          // ç§»é™¤æ—§ç›‘å¬å™¨
          playerListener?.let { player.removeListener(it) }

          // åˆ›å»ºæ–°ç›‘å¬å™¨
          playerListener = performanceMonitor.createPlayerListener(
              videoUrl = video.url,
              pageIndex = position
          ).also {
              player.addListener(it)
              (it as? VideoPerformanceMonitor.VideoPlayerListener)?.onVideoLoadStart()
          }

          // è®¾ç½®è§†é¢‘æº
          player.setMediaItem(MediaItem.fromUri(video.url))
          player.prepare()
      }
  }

  ---
  å…³é”®æ€§èƒ½æŒ‡æ ‡å»ºè®®

  åŸºäºæŠ–éŸ³ã€å¿«æ‰‹ç­‰åº”ç”¨çš„å®è·µï¼Œä½ åº”è¯¥å…³æ³¨ï¼š

  æ ¸å¿ƒæŒ‡æ ‡ï¼š

  1. é¦–å¸§åŠ è½½æ—¶é—´ (First Frame Time)
    - ä¼˜ç§€: < 500ms
    - è‰¯å¥½: 500-1000ms
    - éœ€ä¼˜åŒ–: > 1000ms
  2. å¡é¡¿ç‡ (Buffering Ratio)
    - å¡é¡¿æ€»æ—¶é•¿ / æ’­æ”¾æ€»æ—¶é•¿
    - ä¼˜ç§€: < 1%
    - å¯æ¥å—: 1-5%
    - éœ€ä¼˜åŒ–: > 5%
  3. å¡é¡¿æ¬¡æ•° (Buffering Count)
    - å•æ¬¡è§‚çœ‹å¡é¡¿æ¬¡æ•°
  4. æ’­æ”¾æˆåŠŸç‡ (Play Success Rate)
    - æˆåŠŸæ’­æ”¾æ¬¡æ•° / å°è¯•æ’­æ”¾æ¬¡æ•°
  5. é¡µé¢åˆ‡æ¢è€—æ—¶ (Page Switch Duration)
    - æ»‘åŠ¨å¼€å§‹åˆ°æ–°è§†é¢‘é¦–å¸§

  è¾…åŠ©æŒ‡æ ‡ï¼š

  - è§†é¢‘å®Œæ’­ç‡ (Completion Rate)
  - å¹³å‡è§‚çœ‹æ—¶é•¿ (Average Watch Time)
  - é”™è¯¯ç‡ (Error Rate)
  - å†…å­˜å ç”¨ (Memory Usage)

  ---
  æ€»ç»“

  ä½ çš„æ€è·¯å®Œå…¨æ­£ç¡®ï¼ äº‹ä»¶æ‹¦æˆªå™¨/ä»£ç†æ¨¡å¼æ˜¯æœ€ä½³æ–¹æ¡ˆï¼ŒåŸå› ï¼š

  âœ… æ— ä¾µå…¥: ä¸æ±¡æŸ“ä¸šåŠ¡ä»£ç âœ… å¯ç»´æŠ¤: åŸ‹ç‚¹é€»è¾‘é›†ä¸­ç®¡ç†âœ… å¯æµ‹è¯•: ç›‘æ§é€»è¾‘ç‹¬ç«‹å¯æµ‹âœ… å¯é…ç½®: å¯åŠ¨æ€å¼€å…³ã€é‡‡æ ·âœ… ç¬¦åˆæ¶æ„: ä¸ä½ çš„ MVVM + Hilt å®Œç¾é…åˆ

  å»ºè®®å®ç°é¡ºåºï¼š
  1. å…ˆå®ç°åŸºç¡€çš„ VideoPerformanceMonitor
  2. åœ¨å¼€å‘ç¯å¢ƒé€šè¿‡ Logcat éªŒè¯æ•°æ®
  3. æ¥å…¥ä½ çš„åŸ‹ç‚¹ç³»ç»Ÿ (Firebase/è‡ªå»º)
  4. å»ºç«‹ç›‘æ§çœ‹æ¿åˆ†ææ•°æ®

  éœ€è¦æˆ‘æä¾›å®Œæ•´çš„ Hilt æ¨¡å—é…ç½®å’Œæµ‹è¯•ä»£ç å—ï¼Ÿ

> æˆ‘ç°åœ¨å®Œæˆäº†åŸºç¡€çš„å®ç°ï¼Œä½†æ˜¯æˆ‘çš„æ‰€æœ‰ FIRST FRAME TIMEéƒ½æ˜¾ç¤º0ms ä½ è§‰å¾—è¿™æ˜¯ä¸ºä»€ä¹ˆ 

âº è¿™æ˜¯ä¸ªç»å…¸é—®é¢˜ï¼firstFrameTime æ˜¾ç¤º 0ms é€šå¸¸æœ‰å‡ ä¸ªå¯èƒ½çš„åŸå› ï¼Œè®©æˆ‘å¸®ä½ è¯Šæ–­ï¼š

  å¯èƒ½çš„åŸå› åˆ†æ

  åŸå›  1ï¼šæ—¶é—´è®°å½•ç‚¹ä¸æ­£ç¡®ï¼ˆæœ€å¸¸è§ï¼‰

  é—®é¢˜ï¼š loadStartTime çš„è®°å½•æ—¶æœºå’Œé¦–å¸§å°±ç»ªæ£€æµ‹é€»è¾‘æœ‰é—®é¢˜

  // âŒ é”™è¯¯ç¤ºä¾‹
  override fun onPlaybackStateChanged(playbackState: Int) {
      when (playbackState) {
          Player.STATE_READY -> {
              if (loadStartTime > 0) {
                  val firstFrameTime = System.currentTimeMillis() - loadStartTime
                  // å¯èƒ½ loadStartTime ä»æœªè¢«è®¾ç½®ï¼Œæˆ–è€…åœ¨ READY ä¹‹å‰å°±è¢«é‡ç½®äº†
              }
          }
      }
  }

  è§£å†³æ–¹æ¡ˆï¼š ç¡®ä¿è®¡æ—¶é€»è¾‘æ­£ç¡®

  private inner class VideoPlayerListener(
      private val videoUrl: String,
      private val pageIndex: Int
  ) : Player.Listener {

      private var loadStartTime = 0L
      private var isFirstFrame = true  // å…³é”®ï¼šæ ‡è®°æ˜¯å¦æ˜¯é¦–å¸§

      // è¿™ä¸ªæ–¹æ³•éœ€è¦åœ¨ setMediaItem ä¹‹å‰è°ƒç”¨
      fun onVideoLoadStart() {
          loadStartTime = System.currentTimeMillis()
          isFirstFrame = true
          Log.d("Performance", "[$videoUrl] Load start at $loadStartTime")
      }

      override fun onPlaybackStateChanged(playbackState: Int) {
          Log.d("Performance", "[$videoUrl] State changed: $playbackState")

          when (playbackState) {
              Player.STATE_READY -> {
                  // å…³é”®ï¼šåªåœ¨é¦–æ¬¡ READY æ—¶è®¡ç®—
                  if (isFirstFrame && loadStartTime > 0) {
                      val firstFrameTime = System.currentTimeMillis() - loadStartTime
                      Log.d("Performance", "[$videoUrl] First frame: ${firstFrameTime}ms")

                      // è®°å½•æŒ‡æ ‡
                      val metrics = metricsMap[videoUrl] ?: VideoMetrics(videoUrl, pageIndex = pageIndex)
                      metricsMap[videoUrl] = metrics.copy(firstFrameTime = firstFrameTime)

                      // é‡ç½®æ ‡è®°
                      isFirstFrame = false
                      loadStartTime = 0
                  } else {
                      Log.d("Performance", "[$videoUrl] Not first frame or loadStartTime not set")
                  }
              }
          }
      }
  }

  ---
  åŸå›  2ï¼šonVideoLoadStart() è°ƒç”¨æ—¶æœºé”™è¯¯

  æ£€æŸ¥ä½ çš„ ViewHolder ä»£ç ï¼š

  // âŒ é”™è¯¯ï¼šåœ¨ prepare() ä¹‹åè°ƒç”¨
  fun bind(video: Video, position: Int) {
      player.setMediaItem(MediaItem.fromUri(video.url))
      player.prepare()
      player.play()

      // å¤ªæ™šäº†ï¼è¿™æ—¶ STATE_READY å¯èƒ½å·²ç»è§¦å‘
      playerListener?.onVideoLoadStart()
  }

  // âœ… æ­£ç¡®ï¼šåœ¨ setMediaItem ä¹‹å‰è°ƒç”¨
  fun bind(video: Video, position: Int) {
      // 1. å…ˆè®¾ç½®ç›‘å¬å™¨å’Œå¼€å§‹è®¡æ—¶
      playerListener = performanceMonitor.createPlayerListener(video.url, position)
      player.addListener(playerListener)
      (playerListener as? VideoPlayerListener)?.onVideoLoadStart()

      // 2. å†è®¾ç½®åª’ä½“æº
      player.setMediaItem(MediaItem.fromUri(video.url))
      player.prepare()
      player.play()
  }

  ---
  åŸå›  3ï¼šExoPlayer ç¼“å­˜å¯¼è‡´

  é—®é¢˜ï¼š å¦‚æœè§†é¢‘å·²ç»ç¼“å­˜ï¼ŒExoPlayer å¯èƒ½åœ¨ prepare() è°ƒç”¨æ—¶å°±å·²ç»æ˜¯ STATE_READYï¼Œå¯¼è‡´ï¼š
  - onPlaybackStateChanged åœ¨ addListener ä¹‹å‰å°±è§¦å‘äº†
  - æˆ–è€…è§¦å‘å¤ªå¿«ï¼ŒloadStartTime è¿˜æœªè®¾ç½®

  è§£å†³æ–¹æ¡ˆï¼š è°ƒæ•´ç›‘å¬å™¨æ³¨å†Œé¡ºåº

  fun bind(video: Video, position: Int) {
      // 1. å…ˆåœæ­¢å¹¶é‡ç½®æ’­æ”¾å™¨
      player.stop()
      player.clearMediaItems()

      // 2. ç§»é™¤æ—§ç›‘å¬å™¨
      playerListener?.let { player.removeListener(it) }

      // 3. åˆ›å»ºå¹¶æ·»åŠ æ–°ç›‘å¬å™¨ï¼Œå¼€å§‹è®¡æ—¶
      playerListener = performanceMonitor.createPlayerListener(video.url, position).apply {
          onVideoLoadStart()  // å…ˆè®¡æ—¶
          player.addListener(this)  // å†æ³¨å†Œç›‘å¬
      }

      // 4. è®¾ç½®åª’ä½“æºå¹¶å‡†å¤‡
      player.setMediaItem(MediaItem.fromUri(video.url))
      player.prepare()

      // 5. æ ¹æ®æ˜¯å¦æ˜¯å½“å‰é¡µé¢å†³å®šæ˜¯å¦è‡ªåŠ¨æ’­æ”¾
      if (shouldAutoPlay) {
          player.play()
      }
  }

  ---
  åŸå›  4ï¼šä½¿ç”¨äº† onRenderedFirstFrame ä½†æ²¡æ­£ç¡®å¤„ç†

  ExoPlayer æä¾›äº†æ›´ç²¾ç¡®çš„é¦–å¸§å›è°ƒï¼š

  override fun onRenderedFirstFrame() {
      // è¿™ä¸ªå›è°ƒæ›´å‡†ç¡®ï¼Œè¡¨ç¤ºé¦–å¸§çœŸæ­£æ¸²æŸ“åˆ°å±å¹•
      if (isFirstFrame && loadStartTime > 0) {
          val firstFrameTime = System.currentTimeMillis() - loadStartTime
          Log.d("Performance", "First frame rendered: ${firstFrameTime}ms")

          // è®°å½•æŒ‡æ ‡...
          isFirstFrame = false
      }
  }

  override fun onPlaybackStateChanged(playbackState: Int) {
      // ä¿ç•™ STATE_READY çš„é€»è¾‘ä½œä¸ºå¤‡ç”¨
      if (playbackState == Player.STATE_READY && isFirstFrame && loadStartTime > 0) {
          Log.d("Performance", "STATE_READY but waiting for onRenderedFirstFrame")
      }
  }

  ---
  å®Œæ•´çš„è°ƒè¯•ç‰ˆæœ¬

  @Singleton
  class VideoPerformanceMonitor @Inject constructor() {

      private val metricsMap = mutableMapOf<String, VideoMetrics>()

      fun createPlayerListener(videoUrl: String, pageIndex: Int): VideoPlayerListener {
          return VideoPlayerListener(videoUrl, pageIndex)
      }

      inner class VideoPlayerListener(
          private val videoUrl: String,
          private val pageIndex: Int
      ) : Player.Listener {

          private var loadStartTime = 0L
          private var isFirstFrame = true
          private val tag = "VideoPerf"

          fun onVideoLoadStart() {
              loadStartTime = System.currentTimeMillis()
              isFirstFrame = true
              Log.d(tag, "=== [$videoUrl] Video load started at $loadStartTime ===")
          }

          override fun onPlaybackStateChanged(playbackState: Int) {
              val stateName = when (playbackState) {
                  Player.STATE_IDLE -> "IDLE"
                  Player.STATE_BUFFERING -> "BUFFERING"
                  Player.STATE_READY -> "READY"
                  Player.STATE_ENDED -> "ENDED"
                  else -> "UNKNOWN"
              }

              Log.d(tag, "[$videoUrl] State: $stateName, isFirstFrame: $isFirstFrame, loadStartTime: $loadStartTime")

              when (playbackState) {
                  Player.STATE_READY -> {
                      if (isFirstFrame && loadStartTime > 0) {
                          val now = System.currentTimeMillis()
                          val firstFrameTime = now - loadStartTime

                          Log.d(tag, "[$videoUrl] âœ… First frame time: ${firstFrameTime}ms (start: $loadStartTime, now: $now)")

                          val metrics = metricsMap.getOrPut(videoUrl) {
                              VideoMetrics(videoUrl, pageIndex = pageIndex)
                          }
                          metricsMap[videoUrl] = metrics.copy(firstFrameTime = firstFrameTime)

                          isFirstFrame = false
                      } else {
                          Log.w(tag, "[$videoUrl] âš ï¸ Skipped: isFirstFrame=$isFirstFrame, loadStartTime=$loadStartTime")
                      }
                  }
              }
          }

          // æ›´ç²¾ç¡®çš„é¦–å¸§æ£€æµ‹
          override fun onRenderedFirstFrame() {
              if (isFirstFrame && loadStartTime > 0) {
                  val firstFrameTime = System.currentTimeMillis() - loadStartTime
                  Log.d(tag, "[$videoUrl] ğŸ¬ First frame RENDERED: ${firstFrameTime}ms")

                  val metrics = metricsMap[videoUrl] ?: VideoMetrics(videoUrl, pageIndex = pageIndex)
                  metricsMap[videoUrl] = metrics.copy(firstFrameTime = firstFrameTime)

                  isFirstFrame = false
              }
          }

          override fun onPlayerError(error: PlaybackException) {
              Log.e(tag, "[$videoUrl] âŒ Error: ${error.message}", error)
          }
      }

      data class VideoMetrics(
          val videoUrl: String,
          val firstFrameTime: Long = 0,
          val pageIndex: Int = 0
      )
  }

  ---
  æ’æŸ¥æ­¥éª¤

  1. æ·»åŠ æ—¥å¿—æŸ¥çœ‹è°ƒç”¨é¡ºåºï¼š

  // åœ¨ ViewHolder.bind() ä¸­
  fun bind(video: Video, position: Int) {
      Log.d("VideoHolder", "=== Binding video: ${video.url}, position: $position ===")

      // ... ä½ çš„ä»£ç 
      playerListener?.onVideoLoadStart()
      Log.d("VideoHolder", "onVideoLoadStart called")

      player.setMediaItem(...)
      Log.d("VideoHolder", "setMediaItem called")

      player.prepare()
      Log.d("VideoHolder", "prepare called")
  }

  2. æŸ¥çœ‹ Logcat è¾“å‡ºï¼Œæ­£å¸¸åº”è¯¥æ˜¯ï¼š

  VideoHolder: === Binding video: xxx, position: 0 ===
  VideoPerf: === [xxx] Video load started at 1733472000123 ===
  VideoHolder: onVideoLoadStart called
  VideoHolder: setMediaItem called
  VideoHolder: prepare called
  VideoPerf: [xxx] State: BUFFERING, isFirstFrame: true, loadStartTime: 1733472000123
  VideoPerf: [xxx] State: READY, isFirstFrame: true, loadStartTime: 1733472000123
  VideoPerf: [xxx] âœ… First frame time: 856ms

  3. å¦‚æœçœ‹åˆ°çš„æ˜¯ï¼š

  VideoPerf: [xxx] State: READY, isFirstFrame: false, loadStartTime: 0

  è¯´æ˜ onVideoLoadStart() æ²¡è¢«è°ƒç”¨æˆ–è°ƒç”¨å¤ªæ™šã€‚

  ---
  ä½ å¯ä»¥å…ˆæŠŠè¿™ä¸ªå¸¦æ—¥å¿—çš„ç‰ˆæœ¬è·‘èµ·æ¥ï¼ŒæŠŠ Logcat è¾“å‡ºè´´ç»™æˆ‘ï¼Œæˆ‘å¸®ä½ çœ‹å…·ä½“æ˜¯å“ªä¸ªç¯èŠ‚å‡ºäº†é—®é¢˜ã€‚

> å¯¹äºè¿™ä¸ªä¼˜åŒ–åœºæ™¯ï¼Œæˆ‘æ˜¯ä¸æ˜¯è¿˜å¾—è€ƒè™‘å†…å­˜å ç”¨ï¼Œå¹¶ä¸”åœ¨æ•°æ®åˆ†æä¸­è€ƒè™‘è¿™ç§æ•°æ® 

âº éå¸¸å¥½çš„æ´å¯Ÿï¼å†…å­˜å ç”¨ç»å¯¹æ˜¯è§†é¢‘æµåº”ç”¨çš„æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡ï¼Œè€Œä¸”å¯¹äºä½ è¿™ç§åŸºäº ViewPager2 + ExoPlayer çš„æ¶æ„æ¥è¯´å°¤ä¸ºé‡è¦ã€‚

  ä¸ºä»€ä¹ˆå†…å­˜ç›‘æ§è‡³å…³é‡è¦

  1. è§†é¢‘åº”ç”¨çš„å†…å­˜ç‰¹ç‚¹

  - å•ä¸ª ExoPlayer å®ä¾‹ï¼š~20-50MB
  - è§†é¢‘ç¼“å†²åŒºï¼šæ¯ä¸ªè§†é¢‘ 10-30MB
  - Bitmap ç¼“å­˜ï¼ˆå°é¢å›¾ï¼‰ï¼šæ¯å¼  2-5MB
  - RecyclerView ViewHolder æ± ï¼šå¤šä¸ªå®ä¾‹å¹¶å­˜

  é£é™©ï¼š
  - é¢‘ç¹æ»‘åŠ¨å¯¼è‡´å†…å­˜å³°å€¼
  - åå°è§†é¢‘æœªé‡Šæ”¾å¯¼è‡´å†…å­˜æ³„æ¼
  - OOM å´©æºƒ

  2. å…¸å‹é—®é¢˜åœºæ™¯

  ç”¨æˆ·æ»‘åŠ¨ 10 ä¸ªè§†é¢‘ï¼š
  - 5 ä¸ª ExoPlayer æœªé‡Šæ”¾ = 100-250MB
  - 10 ä¸ªè§†é¢‘ç¼“å†²åŒº = 100-300MB
  - æ€»è®¡å¯èƒ½è¶…è¿‡ 400MB â†’ ä½ç«¯è®¾å¤‡ç›´æ¥ OOM

  ---
  éœ€è¦ç›‘æ§çš„å†…å­˜æŒ‡æ ‡

  æ ¸å¿ƒæŒ‡æ ‡

  data class MemoryMetrics(
      // 1. åº”ç”¨çº§å†…å­˜
      val totalMemoryMB: Long,           // åº”ç”¨æ€»å†…å­˜å ç”¨
      val maxMemoryMB: Long,             // å¯ç”¨æœ€å¤§å†…å­˜
      val memoryUsagePercent: Float,     // å†…å­˜ä½¿ç”¨ç‡

      // 2. è§†é¢‘æ’­æ”¾å™¨ç›¸å…³
      val activePlayerCount: Int,        // æ´»è·ƒæ’­æ”¾å™¨æ•°é‡
      val cachedVideoCount: Int,         // ç¼“å­˜çš„è§†é¢‘æ•°é‡
      val estimatedVideoMemoryMB: Long,  // è§†é¢‘å ç”¨å†…å­˜ä¼°ç®—

      // 3. GC å‹åŠ›
      val gcCount: Int,                  // GC è§¦å‘æ¬¡æ•°
      val gcTotalTime: Long,             // GC æ€»è€—æ—¶

      // 4. å†…å­˜å¢é•¿
      val memoryGrowthRate: Float,       // å†…å­˜å¢é•¿é€Ÿç‡ (MB/min)
      val leakSuspicion: Boolean         // æ˜¯å¦ç–‘ä¼¼å†…å­˜æ³„æ¼
  )

  ---
  å®Œæ•´çš„æ€§èƒ½ç›‘æ§æ–¹æ¡ˆï¼ˆå«å†…å­˜ï¼‰

  @Singleton
  class VideoPerformanceMonitor @Inject constructor(
      @ApplicationContext private val context: Context,
      private val analyticsService: AnalyticsService
  ) {

      private val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
      private val runtime = Runtime.getRuntime()

      // æ€§èƒ½æŒ‡æ ‡
      data class VideoMetrics(
          val videoUrl: String,
          val pageIndex: Int = 0,

          // æ’­æ”¾æ€§èƒ½
          val firstFrameTime: Long = 0,
          val totalBufferingTime: Long = 0,
          val bufferingCount: Int = 0,
          val playDuration: Long = 0,
          val errorCount: Int = 0,

          // å†…å­˜å¿«ç…§
          val memoryAtStart: Long = 0,       // å¼€å§‹æ’­æ”¾æ—¶å†…å­˜
          val memoryAtEnd: Long = 0,         // ç»“æŸæ’­æ”¾æ—¶å†…å­˜
          val memoryDelta: Long = 0,         // å†…å­˜å¢é‡
          val gcCountDuringPlay: Int = 0     // æ’­æ”¾æœŸé—´ GC æ¬¡æ•°
      )

      private val metricsMap = mutableMapOf<String, VideoMetrics>()
      private val activePlayerUrls = mutableSetOf<String>()

      // å…¨å±€å†…å­˜ç›‘æ§
      private var lastGcCount = 0
      private var sessionStartMemory = 0L
      private var sessionStartTime = 0L

      // å¯åŠ¨ç›‘æ§
      fun startMonitoring() {
          sessionStartMemory = getCurrentMemoryMB()
          sessionStartTime = System.currentTimeMillis()
          lastGcCount = getGcCount()

          // å®šæœŸé‡‡æ ·ï¼ˆæ¯ 10 ç§’ï¼‰
          startPeriodicMemorySampling()
      }

      // è·å–å½“å‰å†…å­˜å ç”¨
      private fun getCurrentMemoryMB(): Long {
          val memoryInfo = ActivityManager.MemoryInfo()
          activityManager.getMemoryInfo(memoryInfo)

          return (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
      }

      // è·å–æœ€å¤§å¯ç”¨å†…å­˜
      private fun getMaxMemoryMB(): Long {
          return runtime.maxMemory() / (1024 * 1024)
      }

      // è·å– GC æ¬¡æ•°ï¼ˆè¿‘ä¼¼ï¼‰
      private fun getGcCount(): Int {
          // Android æ²¡æœ‰ç›´æ¥ APIï¼Œé€šè¿‡ Debug ç±»ä¼°ç®—
          val memInfo = Debug.MemoryInfo()
          Debug.getMemoryInfo(memInfo)
          return memInfo.totalPss / 1024 // ç®€åŒ–å¤„ç†
      }

      // å†…å­˜ä½¿ç”¨ç‡
      private fun getMemoryUsagePercent(): Float {
          val current = getCurrentMemoryMB()
          val max = getMaxMemoryMB()
          return (current.toFloat() / max) * 100
      }

      // åˆ›å»ºæ’­æ”¾å™¨ç›‘å¬å™¨
      fun createPlayerListener(videoUrl: String, pageIndex: Int): VideoPlayerListener {
          return VideoPlayerListener(videoUrl, pageIndex)
      }

      inner class VideoPlayerListener(
          private val videoUrl: String,
          private val pageIndex: Int
      ) : Player.Listener {

          private var loadStartTime = 0L
          private var isFirstFrame = true
          private var playStartTime = 0L
          private var bufferingStartTime = 0L

          // å†…å­˜ç›¸å…³
          private var memoryAtStart = 0L
          private var gcCountAtStart = 0

          fun onVideoLoadStart() {
              loadStartTime = System.currentTimeMillis()
              isFirstFrame = true

              // è®°å½•å†…å­˜å¿«ç…§
              memoryAtStart = getCurrentMemoryMB()
              gcCountAtStart = getGcCount()

              // æ ‡è®°ä¸ºæ´»è·ƒæ’­æ”¾å™¨
              activePlayerUrls.add(videoUrl)

              Log.d("MemoryMonitor", "[$videoUrl] Load start - Memory: ${memoryAtStart}MB, Active players: ${activePlayerUrls.size}")
          }

          override fun onPlaybackStateChanged(playbackState: Int) {
              when (playbackState) {
                  Player.STATE_BUFFERING -> {
                      if (bufferingStartTime == 0L) {
                          bufferingStartTime = System.currentTimeMillis()
                      }
                  }

                  Player.STATE_READY -> {
                      // é¦–å¸§æ—¶é—´
                      if (isFirstFrame && loadStartTime > 0) {
                          val firstFrameTime = System.currentTimeMillis() - loadStartTime
                          val currentMemory = getCurrentMemoryMB()

                          val metrics = metricsMap.getOrPut(videoUrl) {
                              VideoMetrics(videoUrl, pageIndex = pageIndex)
                          }

                          metricsMap[videoUrl] = metrics.copy(
                              firstFrameTime = firstFrameTime,
                              memoryAtStart = memoryAtStart
                          )

                          Log.d("MemoryMonitor", "[$videoUrl] First frame: ${firstFrameTime}ms, Memory: ${currentMemory}MB (+${currentMemory - memoryAtStart}MB)")

                          isFirstFrame = false
                      }

                      // å¡é¡¿ç»“æŸ
                      if (bufferingStartTime > 0) {
                          val bufferingDuration = System.currentTimeMillis() - bufferingStartTime
                          val metrics = metricsMap[videoUrl] ?: return
                          metricsMap[videoUrl] = metrics.copy(
                              totalBufferingTime = metrics.totalBufferingTime + bufferingDuration,
                              bufferingCount = metrics.bufferingCount + 1
                          )
                          bufferingStartTime = 0
                      }
                  }

                  Player.STATE_ENDED, Player.STATE_IDLE -> {
                      onVideoPlayEnd()
                  }
              }
          }

          override fun onIsPlayingChanged(isPlaying: Boolean) {
              if (isPlaying) {
                  playStartTime = System.currentTimeMillis()
              } else if (playStartTime > 0) {
                  val playDuration = System.currentTimeMillis() - playStartTime
                  val metrics = metricsMap[videoUrl] ?: return
                  metricsMap[videoUrl] = metrics.copy(
                      playDuration = metrics.playDuration + playDuration
                  )
              }
          }

          override fun onPlayerError(error: PlaybackException) {
              val metrics = metricsMap[videoUrl] ?: return
              metricsMap[videoUrl] = metrics.copy(errorCount = metrics.errorCount + 1)
              onVideoPlayEnd()
          }

          // è§†é¢‘æ’­æ”¾ç»“æŸ
          private fun onVideoPlayEnd() {
              if (!activePlayerUrls.contains(videoUrl)) return

              val memoryAtEnd = getCurrentMemoryMB()
              val gcCountAtEnd = getGcCount()
              val metrics = metricsMap[videoUrl] ?: return

              val finalMetrics = metrics.copy(
                  memoryAtEnd = memoryAtEnd,
                  memoryDelta = memoryAtEnd - memoryAtStart,
                  gcCountDuringPlay = gcCountAtEnd - gcCountAtStart
              )

              metricsMap[videoUrl] = finalMetrics
              activePlayerUrls.remove(videoUrl)

              Log.d("MemoryMonitor", "[$videoUrl] Play end - Memory: ${memoryAtEnd}MB, Delta: ${finalMetrics.memoryDelta}MB, GC: ${finalMetrics.gcCountDuringPlay}")

              // ä¸ŠæŠ¥å®Œæ•´æŒ‡æ ‡
              reportMetrics(finalMetrics)
          }

          // æ‰‹åŠ¨é‡Šæ”¾ï¼ˆViewHolder å›æ”¶æ—¶è°ƒç”¨ï¼‰
          fun onPlayerReleased() {
              onVideoPlayEnd()
          }
      }

      // å®šæœŸå†…å­˜é‡‡æ ·
      private fun startPeriodicMemorySampling() {
          CoroutineScope(Dispatchers.Default).launch {
              while (true) {
                  delay(10_000) // æ¯ 10 ç§’

                  val currentMemory = getCurrentMemoryMB()
                  val maxMemory = getMaxMemoryMB()
                  val usagePercent = getMemoryUsagePercent()

                  val sessionDuration = (System.currentTimeMillis() - sessionStartTime) / 1000 / 60 // åˆ†é’Ÿ
                  val memoryGrowth = currentMemory - sessionStartMemory
                  val growthRate = if (sessionDuration > 0) memoryGrowth.toFloat() / sessionDuration else 0f

                  // æ£€æµ‹å†…å­˜æ³„æ¼å«Œç–‘
                  val leakSuspicion = growthRate > 5f && sessionDuration > 5 // æ¯åˆ†é’Ÿå¢é•¿è¶…è¿‡ 5MB ä¸”è¿è¡Œè¶…è¿‡ 5 åˆ†é’Ÿ

                  analyticsService.logEvent("memory_sample", mapOf(
                      "current_mb" to currentMemory,
                      "max_mb" to maxMemory,
                      "usage_percent" to usagePercent,
                      "active_players" to activePlayerUrls.size,
                      "growth_rate_mb_per_min" to growthRate,
                      "leak_suspicion" to leakSuspicion,
                      "session_duration_min" to sessionDuration
                  ))

                  // è­¦å‘Šï¼šå†…å­˜ä½¿ç”¨è¶…è¿‡ 80%
                  if (usagePercent > 80) {
                      Log.w("MemoryMonitor", "âš ï¸ High memory usage: ${usagePercent}%, Current: ${currentMemory}MB, Max: ${maxMemory}MB")
                  }

                  // è­¦å‘Šï¼šç–‘ä¼¼å†…å­˜æ³„æ¼
                  if (leakSuspicion) {
                      Log.w("MemoryMonitor", "âš ï¸ Possible memory leak! Growth rate: ${growthRate}MB/min")
                  }
              }
          }
      }

      // ä¸ŠæŠ¥æŒ‡æ ‡
      private fun reportMetrics(metrics: VideoMetrics) {
          analyticsService.logEvent("video_session_complete", mapOf(
              "video_url" to metrics.videoUrl,
              "page_index" to metrics.pageIndex,

              // æ’­æ”¾æ€§èƒ½
              "first_frame_time" to metrics.firstFrameTime,
              "total_buffering_time" to metrics.totalBufferingTime,
              "buffering_count" to metrics.bufferingCount,
              "play_duration" to metrics.playDuration,
              "error_count" to metrics.errorCount,

              // å†…å­˜æŒ‡æ ‡
              "memory_at_start" to metrics.memoryAtStart,
              "memory_at_end" to metrics.memoryAtEnd,
              "memory_delta" to metrics.memoryDelta,
              "gc_count" to metrics.gcCountDuringPlay,

              // ä½“éªŒè¯„åˆ†
              "qoe_score" to calculateQoE(metrics)
          ))

          metricsMap.remove(metrics.videoUrl)
      }

      // è®¡ç®— QoE è¯„åˆ†ï¼ˆå¢åŠ å†…å­˜æƒé‡ï¼‰
      private fun calculateQoE(metrics: VideoMetrics): Float {
          // é¦–å¸§æ—¶é—´è¯„åˆ†
          val firstFrameScore = when {
              metrics.firstFrameTime < 500 -> 1.0f
              metrics.firstFrameTime < 1000 -> 0.8f
              metrics.firstFrameTime < 2000 -> 0.5f
              else -> 0.2f
          }

          // å¡é¡¿è¯„åˆ†
          val bufferingRatio = if (metrics.playDuration > 0) {
              metrics.totalBufferingTime.toFloat() / metrics.playDuration
          } else 0f
          val bufferingScore = (1 - bufferingRatio).coerceAtLeast(0f)

          // å†…å­˜è¯„åˆ†ï¼ˆæ–°å¢ï¼‰
          val memoryScore = when {
              metrics.memoryDelta < 10 -> 1.0f   // å¢é•¿å°äº 10MB
              metrics.memoryDelta < 30 -> 0.8f   // 10-30MB
              metrics.memoryDelta < 50 -> 0.5f   // 30-50MB
              else -> 0.2f                        // è¶…è¿‡ 50MB
          }

          // ç»¼åˆè¯„åˆ†ï¼šé¦–å¸§ 30% + å¡é¡¿ 50% + å†…å­˜ 20%
          return (firstFrameScore * 0.3f + bufferingScore * 0.5f + memoryScore * 0.2f) * 100
      }

      // è·å–å½“å‰å†…å­˜å¿«ç…§
      fun getCurrentMemorySnapshot(): Map<String, Any> {
          return mapOf(
              "current_memory_mb" to getCurrentMemoryMB(),
              "max_memory_mb" to getMaxMemoryMB(),
              "usage_percent" to getMemoryUsagePercent(),
              "active_players" to activePlayerUrls.size,
              "active_videos" to activePlayerUrls.toList()
          )
      }
  }

  ---
  åœ¨ ViewHolder ä¸­æ­£ç¡®é‡Šæ”¾

  class VideoViewHolder(
      private val performanceMonitor: VideoPerformanceMonitor
  ) : RecyclerView.ViewHolder(binding.root) {

      private var playerListener: VideoPerformanceMonitor.VideoPlayerListener? = null

      fun bind(video: Video, position: Int) {
          // é‡Šæ”¾æ—§ç›‘å¬å™¨
          releasePlayer()

          // åˆ›å»ºæ–°ç›‘å¬å™¨
          playerListener = performanceMonitor.createPlayerListener(video.url, position).apply {
              onVideoLoadStart()
              player.addListener(this)
          }

          player.setMediaItem(MediaItem.fromUri(video.url))
          player.prepare()
      }

      // ViewHolder å›æ”¶æ—¶é‡Šæ”¾
      fun releasePlayer() {
          playerListener?.let {
              it.onPlayerReleased()  // è§¦å‘å†…å­˜é‡‡æ ·
              player.removeListener(it)
          }
          playerListener = null
          player.stop()
          player.clearMediaItems()
      }
  }

  åœ¨ Adapter ä¸­ï¼š

  override fun onViewRecycled(holder: VideoViewHolder) {
      super.onViewRecycled(holder)
      holder.releasePlayer()  // ç¡®ä¿é‡Šæ”¾
  }

  ---
  æ•°æ®åˆ†æç»´åº¦

  1. å†…å­˜å¥åº·åº¦åˆ†æ

  -- è®¡ç®—å¹³å‡å†…å­˜å¢é•¿
  SELECT
      AVG(memory_delta) as avg_memory_growth,
      MAX(memory_delta) as max_memory_growth,
      COUNT(CASE WHEN memory_delta > 50 THEN 1 END) as high_memory_sessions
  FROM video_sessions
  WHERE date >= CURRENT_DATE - 7

  2. å†…å­˜ä¸æ€§èƒ½å…³è”

  é«˜å†…å­˜åœºæ™¯ (memory_delta > 50MB):
  - å¹³å‡é¦–å¸§æ—¶é—´: 1200ms
  - å¹³å‡å¡é¡¿ç‡: 8%

  ä½å†…å­˜åœºæ™¯ (memory_delta < 20MB):
  - å¹³å‡é¦–å¸§æ—¶é—´: 600ms
  - å¹³å‡å¡é¡¿ç‡: 2%

  ç»“è®º: å†…å­˜å‹åŠ›ç›´æ¥å½±å“æ’­æ”¾æ€§èƒ½

  3. è®¾å¤‡åˆ†çº§ä¼˜åŒ–

  // æ ¹æ®è®¾å¤‡å†…å­˜è°ƒæ•´ç­–ç•¥
  val deviceMemoryClass = activityManager.memoryClass

  when {
      deviceMemoryClass < 256 -> {
          // ä½ç«¯è®¾å¤‡ï¼šé™åˆ¶ç¼“å­˜ã€é™ä½é¢„åŠ è½½
          maxCachedVideos = 2
          preloadDistance = 1
      }
      deviceMemoryClass < 512 -> {
          // ä¸­ç«¯è®¾å¤‡
          maxCachedVideos = 3
          preloadDistance = 2
      }
      else -> {
          // é«˜ç«¯è®¾å¤‡
          maxCachedVideos = 5
          preloadDistance = 3
      }
  }

  ---
  å…³é”®å‘Šè­¦æŒ‡æ ‡

  åº”è¯¥ç›‘æ§çš„å¼‚å¸¸

  1. å†…å­˜ä½¿ç”¨ç‡ > 85%: è§¦å‘ä¸»åŠ¨ GC æˆ–æ¸…ç†ç¼“å­˜
  2. å†…å­˜å¢é•¿ç‡ > 5MB/min: ç–‘ä¼¼å†…å­˜æ³„æ¼
  3. æ´»è·ƒæ’­æ”¾å™¨æ•° > 3: å¯èƒ½æœ‰æ’­æ”¾å™¨æœªé‡Šæ”¾
  4. å•æ¬¡å†…å­˜å¢é•¿ > 100MB: å¼‚å¸¸åŠ è½½

  ---
  æ€»ç»“

  âœ… å¿…é¡»ç›‘æ§å†…å­˜ï¼ŒåŸå› ï¼š
  1. è§†é¢‘åº”ç”¨å†…å­˜æ•æ„Ÿï¼ŒOOM æ˜¯ä¸»è¦å´©æºƒåŸå› 
  2. å†…å­˜å‹åŠ›ç›´æ¥å½±å“æ’­æ”¾æµç•…åº¦
  3. å¯ä»¥å‘ç°æ’­æ”¾å™¨æ³„æ¼é—®é¢˜
  4. æŒ‡å¯¼è®¾å¤‡åˆ†çº§ä¼˜åŒ–ç­–ç•¥

  å»ºè®®çš„æ•°æ®åˆ†ææŠ¥è¡¨ï¼š
  - å†…å­˜ä½¿ç”¨åˆ†å¸ƒå›¾ï¼ˆP50/P90/P99ï¼‰
  - å†…å­˜å¢é•¿è¶‹åŠ¿ï¼ˆæŒ‰è®¾å¤‡å‹å·ï¼‰
  - å†…å­˜ä¸é¦–å¸§æ—¶é—´ç›¸å…³æ€§
  - OOM å´©æºƒä¸å†…å­˜å³°å€¼å…³è”

  éœ€è¦æˆ‘æä¾›ä¸€ä¸ªå®Œæ•´çš„æ€§èƒ½ç›‘æ§çœ‹æ¿æ–¹æ¡ˆå—ï¼Ÿ

> æˆ‘å¯ä»¥ç”¨ Android Studio Profiler æ¥ç›‘æ§å— 

âº å½“ç„¶å¯ä»¥ï¼Android Studio Profiler æ˜¯ç›‘æ§è§†é¢‘åº”ç”¨æ€§èƒ½çš„æœ€ä½³å·¥å…·ä¹‹ä¸€ï¼Œè€Œä¸”æ¯”ä»£ç åŸ‹ç‚¹æ›´ç›´è§‚ã€‚è®©æˆ‘è¯¦ç»†è¯´æ˜å¦‚ä½•ä½¿ç”¨ã€‚

  Android Studio Profiler çš„ä¼˜åŠ¿

  å¯¹æ¯”ä»£ç åŸ‹ç‚¹

  | ç‰¹æ€§        | Android Studio Profiler | ä»£ç åŸ‹ç‚¹      |
  |-----------|-------------------------|-----------|
  | å®æ—¶å¯è§†åŒ–     | âœ… å›¾è¡¨ã€æ—¶é—´è½´                | âŒ åªæœ‰æ—¥å¿—/æ•°æ® |
  | å†å²å›æº¯      | âœ… å¯å½•åˆ¶ä¼šè¯                 | âš ï¸ éœ€è¦å­˜å‚¨   |
  | CPU/å†…å­˜/ç½‘ç»œ | âœ… å…¨é¢è¦†ç›–                  | âš ï¸ éœ€è¦åˆ†åˆ«å®ç° |
  | æ–¹æ³•è¿½è¸ª      | âœ… å†…ç½®                    | âŒ éœ€è¦æ‰‹åŠ¨åŸ‹ç‚¹  |
  | å†…å­˜æ³„æ¼æ£€æµ‹    | âœ… Heap Dump             | âŒ éš¾ä»¥å®ç°    |
  | ç”Ÿäº§ç¯å¢ƒ      | âŒ ä»…å¼€å‘æœŸ                  | âœ… å¯ç”¨äºçº¿ä¸Š   |
  | å­¦ä¹ æˆæœ¬      | ä½ï¼ˆå›¾å½¢åŒ–ï¼‰                  | ä¸­ï¼ˆéœ€è¦ç†è§£æŒ‡æ ‡ï¼‰ |

  ç»“è®ºï¼š
  - å¼€å‘è°ƒè¯•æœŸï¼šä¼˜å…ˆç”¨ Profilerï¼ˆæ›´å¿«å®šä½é—®é¢˜ï¼‰
  - ç”Ÿäº§ç¯å¢ƒï¼šå¿…é¡»ç”¨ä»£ç åŸ‹ç‚¹ï¼ˆæ”¶é›†ç”¨æˆ·çœŸå®æ•°æ®ï¼‰
  - æœ€ä½³å®è·µï¼šä¸¤è€…ç»“åˆ

  ---
  å¦‚ä½•ç”¨ Profiler ç›‘æ§ä½ çš„è§†é¢‘åº”ç”¨

  1. å†…å­˜ç›‘æ§ï¼ˆMemory Profilerï¼‰

  å¯åŠ¨æ­¥éª¤

  1. è¿è¡Œåº”ç”¨ï¼ˆDebug æˆ– Profile æ¨¡å¼ï¼‰
  2. æ‰“å¼€ Android Studio â†’ View â†’ Tool Windows â†’ Profiler
  3. ç‚¹å‡» Memory æ—¶é—´è½´

  å…³é”®è§‚å¯Ÿç‚¹

  a) å®æ—¶å†…å­˜æ›²çº¿
  æ­£å¸¸æ¨¡å¼ï¼š
  â”â”â”â•±â•²â•±â•²â•±â•²â”â”  å†…å­˜åœ¨ 100-150MB ä¹‹é—´æ³¢åŠ¨ï¼Œæœ‰è§„å¾‹çš„ GC

  å†…å­˜æ³„æ¼ï¼š
  â”â”â”â•±â”â”â•±â”â”â•±â”â”â”â•±  æŒç»­ä¸Šå‡ï¼ŒGC åä¸å›è½

  è§†é¢‘åˆ‡æ¢æŠ–åŠ¨ï¼š
  â”â”â•±â•²â”â”â•±â•²â”â”â•±â•²  æ¯æ¬¡åˆ‡æ¢è§†é¢‘å†…å­˜å‰§çƒˆæ³¢åŠ¨

  b) å…·ä½“æ“ä½œ

  1ï¸âƒ£ æµ‹è¯•è§†é¢‘åˆ‡æ¢çš„å†…å­˜å½±å“
  æ“ä½œæ­¥éª¤ï¼š
  1. å¯åŠ¨ Profiler
  2. è®°å½•å½“å‰å†…å­˜ï¼ˆå¦‚ 120MBï¼‰
  3. æ»‘åŠ¨ 10 ä¸ªè§†é¢‘
  4. è§‚å¯Ÿå†…å­˜å˜åŒ–

  é¢„æœŸç»“æœï¼š
  - è‰¯å¥½ï¼šå†…å­˜å¢é•¿ < 50MBï¼Œç¨³å®šåœ¨ 150-170MB
  - é—®é¢˜ï¼šå†…å­˜å¢é•¿ > 100MB æˆ–æŒç»­ä¸Šå‡

  2ï¸âƒ£ æ£€æµ‹æ’­æ”¾å™¨æ˜¯å¦é‡Šæ”¾
  æ“ä½œï¼š
  1. æ’­æ”¾ 3 ä¸ªè§†é¢‘ååœæ­¢æ»‘åŠ¨
  2. ç‚¹å‡» "Force GC" æŒ‰é’®ï¼ˆåƒåœ¾æ¡¶å›¾æ ‡ï¼‰
  3. è§‚å¯Ÿå†…å­˜æ˜¯å¦å›è½

  é¢„æœŸï¼š
  - âœ… å†…å­˜åº”è¯¥å›åˆ°åˆå§‹æ°´å¹³ Â± 20MB
  - âŒ å¦‚æœè¿˜ç»´æŒé«˜ä½ï¼Œè¯´æ˜æœ‰å¯¹è±¡æœªé‡Šæ”¾

  3ï¸âƒ£ Heap Dump åˆ†æï¼ˆæ£€æµ‹æ³„æ¼ï¼‰
  æ­¥éª¤ï¼š
  1. æ»‘åŠ¨ 5 ä¸ªè§†é¢‘
  2. ç‚¹å‡» "Dump Java Heap" å›¾æ ‡
  3. ç­‰å¾…åˆ†æå®Œæˆ
  4. åœ¨ "Class Name" æœç´¢ï¼š
     - ExoPlayer
     - PlayerView
     - VideoViewHolder

  æ£€æŸ¥ç‚¹ï¼š
  - Retained Size æ˜¯å¦å¼‚å¸¸å¤§
  - Instance Count æ˜¯å¦è¶…è¿‡é¢„æœŸï¼ˆåº”è¯¥ â‰¤ 3ï¼‰

  å®é™…ç¤ºä¾‹ï¼š
  æ­£å¸¸æƒ…å†µï¼š
  com.google.android.exoplayer2.ExoPlayerImpl
    Instances: 2
    Retained: 45.2 MB

  å†…å­˜æ³„æ¼ï¼š
  com.google.android.exoplayer2.ExoPlayerImpl
    Instances: 8  âš ï¸ æ»‘åŠ¨äº† 8 ä¸ªè§†é¢‘ï¼Œä½†éƒ½æ²¡é‡Šæ”¾ï¼
    Retained: 180.4 MB  âš ï¸ å†…å­˜ä¸¥é‡è¶…æ ‡

  ---
  2. CPU ç›‘æ§ï¼ˆCPU Profilerï¼‰

  ç”¨äºåˆ†æè§†é¢‘åˆ‡æ¢å¡é¡¿

  æ“ä½œæ­¥éª¤ï¼š
  1. ç‚¹å‡» CPU æ—¶é—´è½´
  2. ç‚¹å‡» "Record" æŒ‰é’®
  3. æ»‘åŠ¨åˆ‡æ¢ 3-5 ä¸ªè§†é¢‘
  4. ç‚¹å‡» "Stop" åœæ­¢å½•åˆ¶
  5. é€‰æ‹© "Flame Chart" æˆ– "Top Down" è§†å›¾

  å…³é”®åˆ†æç‚¹ï¼š

  1ï¸âƒ£ ä¸»çº¿ç¨‹è€—æ—¶æ–¹æ³•
  æŸ¥æ‰¾ä»¥ä¸‹æ–¹æ³•çš„è€—æ—¶ï¼š
  - onBindViewHolder: åº”è¯¥ < 16ms (60fps)
  - setMediaItem: é¦–æ¬¡è°ƒç”¨å¯èƒ½ 50-100ms
  - prepare: ç½‘ç»œè§†é¢‘å¯èƒ½ 100-500ms

  è­¦å‘Šä¿¡å·ï¼š
  - onBindViewHolder > 30ms â†’ UI ä¼šå¡é¡¿
  - ä¸»çº¿ç¨‹æœ‰ç½‘ç»œè¯·æ±‚ â†’ ä¸¥é‡é—®é¢˜

  2ï¸âƒ£ çº¿ç¨‹åˆ†æ
  æ­£å¸¸æ¨¡å¼ï¼š
  Main Thread: â”â”â•±â•²â”â”â•±â•²â”â”  çŸ­æš‚å³°å€¼åå¿«é€Ÿå›è½
  ExoPlayer:   â”â”â”â”â”â”â”â”â”  æŒç»­ä¸­ç­‰è´Ÿè½½

  é—®é¢˜æ¨¡å¼ï¼š
  Main Thread: â”â”â”â”â”â”â”â”â”  æŒç»­é«˜è´Ÿè½½ï¼Œç•Œé¢ä¼šå¡

  ---
  3. ç½‘ç»œç›‘æ§ï¼ˆNetwork Profilerï¼‰

  ç›‘æ§è§†é¢‘åŠ è½½æµé‡

  æŸ¥çœ‹å†…å®¹ï¼š
  æ—¶é—´è½´æ˜¾ç¤ºï¼š
  æ¯ä¸ªè§†é¢‘çš„ç½‘ç»œè¯·æ±‚ï¼š
  - è¯·æ±‚æ—¶é—´
  - æ•°æ®å¤§å°
  - æŒç»­æ—¶é•¿

  æ£€æŸ¥ç‚¹ï¼š
  1. é¦–æ¬¡åŠ è½½æµé‡ï¼šé€šå¸¸ 2-5MBï¼ˆé¢„åŠ è½½ï¼‰
  2. æ˜¯å¦æœ‰é‡å¤è¯·æ±‚ï¼ˆç¼“å­˜å¤±æ•ˆï¼‰
  3. å¹¶å‘è¯·æ±‚æ•°ï¼ˆåŒæ—¶åŠ è½½å¤šä¸ªè§†é¢‘ä¼šç«äº‰å¸¦å®½ï¼‰

  ä¼˜åŒ–å»ºè®®ï¼š
  å‘ç°ï¼šåŒæ—¶åŠ è½½ 3 ä¸ªè§†é¢‘ â†’ æ¯ä¸ªéƒ½å˜æ…¢
  ä¼˜åŒ–ï¼šé™åˆ¶å¹¶å‘ï¼Œä¼˜å…ˆå½“å‰è§†é¢‘

  ---
  4. èƒ½è€—ç›‘æ§ï¼ˆEnergy Profilerï¼‰

  ç›‘æ§ç”µæ± æ¶ˆè€—ï¼ˆå¯¹è§†é¢‘åº”ç”¨å¾ˆé‡è¦ï¼‰

  å…³é”®æŒ‡æ ‡ï¼š
  - CPU ä½¿ç”¨ç‡
  - ç½‘ç»œæ´»åŠ¨
  - ä½ç½®æœåŠ¡ï¼ˆå¦‚æœç”¨äº†ï¼‰
  - Wake Lockï¼ˆæ˜¯å¦é˜»æ­¢ä¼‘çœ ï¼‰

  ---
  å®æˆ˜ï¼šç”¨ Profiler è¯Šæ–­ä½ çš„é¡¹ç›®

  åœºæ™¯ 1ï¼šé¦–å¸§åŠ è½½æ…¢

  æ­¥éª¤ï¼š
  1. æ‰“å¼€ CPU Profiler
  2. å½•åˆ¶ä¸€æ¬¡è§†é¢‘åŠ è½½è¿‡ç¨‹
  3. åœ¨ Flame Chart ä¸­æŸ¥æ‰¾è€—æ—¶æ–¹æ³•

  å¸¸è§é—®é¢˜ï¼š
  - ä¸»çº¿ç¨‹è§£æ JSON â†’ ç§»åˆ°åå°çº¿ç¨‹
  - åŒæ­¥ç½‘ç»œè¯·æ±‚ â†’ å¿…é¡»å¼‚æ­¥
  - å›¾ç‰‡åŠ è½½é˜»å¡ â†’ æ£€æŸ¥ Coil é…ç½®

  åœºæ™¯ 2ï¼šæ»‘åŠ¨å¡é¡¿

  æ­¥éª¤ï¼š
  1. CPU Profiler + Memory Profiler åŒæ—¶å¼€å¯
  2. å¿«é€Ÿæ»‘åŠ¨ 5 ä¸ªè§†é¢‘
  3. è§‚å¯Ÿï¼š
     - CPU ä¸»çº¿ç¨‹æ˜¯å¦æŒç»­é«˜è´Ÿè½½
     - å†…å­˜æ˜¯å¦é¢‘ç¹ GCï¼ˆé”¯é½¿çŠ¶ï¼‰

  è¯Šæ–­ï¼š
  - é¢‘ç¹ GC â†’ å‡å°‘ä¸´æ—¶å¯¹è±¡åˆ›å»º
  - ä¸»çº¿ç¨‹é«˜è´Ÿè½½ â†’ æ£€æŸ¥ onBindViewHolder

  åœºæ™¯ 3ï¼šå†…å­˜æŒç»­å¢é•¿

  æ­¥éª¤ï¼š
  1. Memory Profiler å¼€å¯
  2. æ»‘åŠ¨ 10 ä¸ªè§†é¢‘
  3. å¼ºåˆ¶ GC
  4. å¦‚æœå†…å­˜ä¸å›è½ â†’ Dump Heap
  5. åœ¨ Heap Dump ä¸­æœç´¢ "Player"
  6. æŸ¥çœ‹ Instance æ•°é‡å’Œ GC Root

  å¸¸è§æ³„æ¼ï¼š
  - ViewHolder æŒæœ‰ Context
  - Listener æœªç§»é™¤
  - Player æœª release()

  ---
  Profiler æœ€ä½³å®è·µ

  å½•åˆ¶ä¼šè¯ï¼ˆå¯å›æ”¾ï¼‰

  æ­¥éª¤ï¼š
  1. Profiler å·¥å…·æ ç‚¹å‡» "Record"
  2. æ‰§è¡Œå®Œæ•´çš„æµ‹è¯•åœºæ™¯ï¼ˆå¦‚æ»‘åŠ¨ 20 ä¸ªè§†é¢‘ï¼‰
  3. ç‚¹å‡» "Stop" åœæ­¢
  4. ä¿å­˜ä¼šè¯ï¼šFile â†’ Export â†’ Trace

  å¥½å¤„ï¼š
  - å¯ä»¥åå¤åˆ†æ
  - å¯ä»¥åˆ†äº«ç»™å›¢é˜Ÿ
  - å¯ä»¥å¯¹æ¯”ä¼˜åŒ–å‰å

  åŸºå‡†æµ‹è¯•

  å»ºç«‹æ€§èƒ½åŸºå‡†ï¼š
  // æµ‹è¯•åœºæ™¯
  1. å†·å¯åŠ¨ â†’ é¦–ä¸ªè§†é¢‘é¦–å¸§æ—¶é—´
  2. è¿ç»­æ»‘åŠ¨ 20 ä¸ªè§†é¢‘ â†’ å†…å­˜å³°å€¼
  3. è¿”å›ç¬¬ 1 ä¸ªè§†é¢‘ â†’ å†…å­˜æ˜¯å¦å›è½

  è®°å½•ï¼š
  | åœºæ™¯ | å†…å­˜å³°å€¼ | å¹³å‡é¦–å¸§ | CPU å³°å€¼ |
  |-----|---------|---------|---------|
  | ä¼˜åŒ–å‰ | 280MB   | 1200ms  | 85%     |
  | ä¼˜åŒ–å | 180MB   | 650ms   | 55%     |

  ---
  Profiler vs ä»£ç åŸ‹ç‚¹çš„é…åˆ

  æ¨èæ–¹æ¡ˆ

  å¼€å‘é˜¶æ®µï¼ˆä½ ç°åœ¨ï¼‰:
  âœ… ä¸»è¦ç”¨ Android Studio Profiler
  - å¿«é€Ÿå®šä½é—®é¢˜
  - å¯è§†åŒ–åˆ†æ
  - ä¸éœ€è¦å†™åŸ‹ç‚¹ä»£ç 

  å‘ç°é—®é¢˜åï¼š
  âœ… æ·»åŠ é’ˆå¯¹æ€§çš„ä»£ç åŸ‹ç‚¹
  - åœ¨é—®é¢˜æ–¹æ³•å‰ååŠ æ—¥å¿—
  - è®°å½•å…³é”®æ—¶é—´ç‚¹

  å‡†å¤‡å‘å¸ƒå‰ï¼š
  âœ… é›†æˆå®Œæ•´çš„æ€§èƒ½ç›‘æ§
  - ä½¿ç”¨æˆ‘ä¹‹å‰æä¾›çš„ VideoPerformanceMonitor
  - æ”¶é›†çœŸå®ç”¨æˆ·æ•°æ®

  å‘å¸ƒåï¼š
  âœ… åˆ†æçº¿ä¸Šæ•°æ®
  - å‘ç°æ–°é—®é¢˜
  - ç”¨ Profiler åœ¨æœ¬åœ°å¤ç°

  ---
  å¸¸è§é—®é¢˜

  Q1: Profiler ä¼šå½±å“æ€§èƒ½å—ï¼Ÿ

  A: ä¼šæœ‰è½»å¾®å½±å“ï¼ˆ~5-10%ï¼‰ï¼Œä½†è¶³å¤Ÿå‡†ç¡®ã€‚å¦‚æœéœ€è¦æ›´ç²¾ç¡®ï¼Œä½¿ç”¨ Profile æ„å»ºå˜ä½“ï¼ˆä¸æ˜¯ Debugï¼‰ã€‚

  Q2: æ€ä¹ˆä¿å­˜ Profiler æ•°æ®ï¼Ÿ

  A:
  Memory: Export heap dump (.hprof)
  CPU: Export trace (.trace)
  æ•´ä¸ªä¼šè¯: Sessions â†’ å³é”® â†’ Export

  Q3: ä½ç«¯è®¾å¤‡æ€ä¹ˆæµ‹è¯•ï¼Ÿ

  A:
  1. åœ¨ Profiler ä¸­æ¨¡æ‹Ÿï¼š
     Developer Options â†’ Process Stats â†’ Limit background processes

  2. ä½¿ç”¨ä½ç«¯çœŸæœºæµ‹è¯•ï¼ˆæ¨èï¼‰

  3. ä½¿ç”¨ Android Virtual Device (AVD) å¹¶é™åˆ¶ RAM

  ---
  å®æˆ˜å»ºè®®

  ä»Šå¤©å°±å¯ä»¥åšçš„æµ‹è¯•

  1. å†…å­˜æ³„æ¼æ£€æµ‹ï¼ˆ10 åˆ†é’Ÿï¼‰
  1. æ‰“å¼€ Memory Profiler
  2. æ»‘åŠ¨ 10 ä¸ªè§†é¢‘
  3. å¼ºåˆ¶ GC
  4. æŸ¥çœ‹å†…å­˜æ˜¯å¦å›è½
  2. é¦–å¸§æ—¶é—´åˆ†æï¼ˆ15 åˆ†é’Ÿï¼‰
  1. æ‰“å¼€ CPU Profiler
  2. å½•åˆ¶åŠ è½½ä¸€ä¸ªè§†é¢‘çš„è¿‡ç¨‹
  3. æŸ¥çœ‹ onBindViewHolder åˆ° onRenderedFirstFrame çš„è€—æ—¶
  4. æ‰¾å‡ºæœ€æ…¢çš„æ–¹æ³•
  3. æ»‘åŠ¨æµç•…åº¦ï¼ˆ10 åˆ†é’Ÿï¼‰
  1. CPU + Memory åŒæ—¶å¼€å¯
  2. å¿«é€Ÿæ»‘åŠ¨ 20 ä¸ªè§†é¢‘
  3. è§‚å¯Ÿæ˜¯å¦æœ‰æ˜æ˜¾å¡é¡¿
  4. å¯¹åº”æŸ¥çœ‹ CPU/Memory å³°å€¼

  ---
  æ€»ç»“

  Android Studio Profiler ç»å¯¹å¤Ÿç”¨ï¼Œè€Œä¸”æ˜¯æœ€ä½³èµ·ç‚¹ï¼š

  âœ… å¼€å‘é˜¶æ®µï¼šProfiler ä¸ºä¸»ï¼ˆå¿«é€Ÿã€ç›´è§‚ã€å…¨é¢ï¼‰âœ… ä¼˜åŒ–é˜¶æ®µï¼šProfiler + ä»£ç åŸ‹ç‚¹ï¼ˆå®šä½ + éªŒè¯ï¼‰âœ… ç”Ÿäº§ç¯å¢ƒï¼šä»£ç åŸ‹ç‚¹ï¼ˆæ”¶é›†çœŸå®æ•°æ®ï¼‰

  å»ºè®®ä½ ï¼š
  1. å…ˆç”¨ Profiler è·‘ä¸€éæˆ‘ä¸Šé¢çš„æµ‹è¯•åœºæ™¯
  2. å‘ç°é—®é¢˜åï¼Œå†å†³å®šæ˜¯å¦éœ€è¦ä»£ç åŸ‹ç‚¹
  3. å‡†å¤‡å‘å¸ƒæ—¶ï¼Œé›†æˆè½»é‡çº§çš„æ€§èƒ½ç›‘æ§

  éœ€è¦æˆ‘æŒ‡å¯¼ä½ åˆ†æå…·ä½“çš„ Profiler æ•°æ®å—ï¼Ÿæ¯”å¦‚ä½ å¯ä»¥æˆªå›¾å‘ç»™æˆ‘çœ‹çœ‹ã€‚



